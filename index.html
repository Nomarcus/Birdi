<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ğŸ¦… NEAT: Evolution Through Hunting (Balanced Build)</title>
  <style>
    :root { --sky1:#87CEEB; --sky2:#E0F6FF; --panel:#ffffffee; --ink:#23303f; --ok:#28a745; --accent:#0d6efd; --danger:#dc3545; }
    *{box-sizing:border-box; margin:0; padding:0;}
    body{ font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      display:flex; flex-direction:column; align-items:center; color:var(--ink); padding:20px; min-height:100vh; }
    h1{ color:#fff; margin:8px 0 16px; text-shadow:0 3px 10px rgba(0,0,0,0.3); font-weight:900; font-size:28px; }
    #canvas{ border:4px solid #2d3748; background:#87CEEB;
      box-shadow:0 20px 60px rgba(0,0,0,.4); border-radius:16px; max-width:100%; }
    .controls{ margin:20px 0; padding:24px; backdrop-filter: blur(16px);
      background:var(--panel); border-radius:20px; box-shadow:0 15px 40px rgba(0,0,0,.2); 
      width:min(1700px,96vw); border:2px solid rgba(255,255,255,0.3); }
    .top-bar{ display:flex; justify-content:space-between; align-items:center; flex-wrap:wrap; gap:16px; margin-bottom:20px; }
    .btn-group{ display:flex; gap:12px; flex-wrap:wrap; }
    .btn{ padding:14px 24px; border:0; border-radius:12px; background:var(--ok); color:#fff;
      font-weight:800; cursor:pointer; box-shadow:0 6px 20px rgba(40,167,69,.3);
      transition:all .2s ease; font-size:15px; display:inline-flex; align-items:center;
      justify-content:center; gap:8px; text-decoration:none; }
    .btn.secondary{ background:var(--accent); box-shadow:0 6px 20px rgba(13,110,253,.3); }
    .btn.danger{ background:var(--danger); box-shadow:0 6px 20px rgba(220,53,69,.3); }
    .btn:hover{ transform:translateY(-2px); filter:brightness(1.1); }
    .speed-control{ display:flex; align-items:center; gap:12px; padding:10px 18px; border-radius:12px;
      background:rgba(255,255,255,0.7); border:2px solid rgba(255,255,255,0.6);
      box-shadow:0 6px 18px rgba(0,0,0,0.12); backdrop-filter:blur(12px); }
    .speed-control label{ font-weight:800; font-size:13px; letter-spacing:0.5px; text-transform:uppercase;
      color:#334155; }
    .speed-control input[type="range"]{ width:180px; accent-color:var(--danger); height:6px;
      background:linear-gradient(90deg, rgba(220,53,69,0.15), rgba(220,53,69,0.4));
      border-radius:999px; cursor:pointer; }
    .speed-value{ font-weight:900; font-size:18px; color:var(--danger); min-width:48px; text-align:right; }
    .score-panel{ display:flex; gap:24px; align-items:center; flex-wrap:wrap; }
    .score-item{ text-align:center; padding:12px 20px; background:rgba(255,255,255,0.5); 
      border-radius:12px; border:2px solid rgba(0,0,0,0.1); }
    .score-label{ font-size:12px; font-weight:700; color:#555; text-transform:uppercase; letter-spacing:0.5px; }
    .score-value{ font-size:28px; font-weight:900; margin-top:4px; }
    .score-value.ok{ color:#28a745; }
    .score-value.danger{ color:#dc3545; }
    .section{ margin:20px 0; }
    .section-title{ font-size:16px; font-weight:900; color:#2d3748; margin-bottom:12px; 
      text-transform:uppercase; letter-spacing:1px; display:flex; align-items:center; gap:8px; 
      border-bottom:3px solid #667eea; padding-bottom:8px; cursor:pointer; user-select:none; }
    .section-title:hover{ opacity:0.8; }
    .section-title::before{ content:'â–¼ '; font-size:12px; }
    .section-title.collapsed::before{ content:'â–¶ '; }
    .collapse-content{ max-height:2000px; overflow:hidden; transition:max-height 0.3s ease; }
    .collapse-content.hidden{ max-height:0; }
    .grid{ display:grid; grid-template-columns:repeat(auto-fit,minmax(300px,1fr)); gap:12px; }
    .control{ display:flex; align-items:center; justify-content:space-between; gap:12px; 
      padding:12px 14px; background:rgba(255,255,255,0.7); border-radius:10px; 
      border:2px solid rgba(0,0,0,0.05); transition:all .2s ease; }
    .control:hover{ background:rgba(255,255,255,0.9); border-color:var(--accent); }
    .control label{ font-weight:700; font-size:13px; color:#2d3748; flex:1; }
    .control input[type="range"]{ width:140px; accent-color:var(--accent); cursor:pointer; }
    .control input[type="number"]{ width:80px; padding:6px; border-radius:6px; border:2px solid #ccc; font-weight:700; }
    .control input[type="checkbox"]{ width:auto; height:20px; cursor:pointer; }
    .chip{ padding:6px 12px; background:#e6f2ff; border:2px solid #b3d9ff; border-radius:999px; 
      font-weight:800; color:#0066cc; min-width:60px; text-align:center; font-size:13px; }
    .chip.danger{ background:#ffe6e6; border-color:#ffb3b3; color:#cc0000; }
    .chip.ok{ background:#e6ffe6; border-color:#b3ffb3; color:#00cc00; }
    .chip.warn{ background:#fff4e6; border-color:#ffd699; color:#cc6600; }
    .stats-grid{ display:grid; grid-template-columns:repeat(auto-fit,minmax(140px,1fr)); gap:14px; margin-top:16px; }
    .stat-card{ padding:16px; background:linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
      border-radius:14px; text-align:center; box-shadow:0 8px 24px rgba(0,0,0,.2); 
      border:2px solid rgba(255,255,255,0.2); color:#fff; }
    .stat-label{ font-size:11px; font-weight:700; text-transform:uppercase; letter-spacing:0.5px; opacity:0.9; }
    .stat-value{ font-size:28px; font-weight:900; margin-top:6px; text-shadow:0 2px 4px rgba(0,0,0,0.2); }
    .bar{ height:6px; background:rgba(255,255,255,0.3); border-radius:999px; overflow:hidden; margin-top:8px; }
    .bar > div{ height:100%; width:0%; transition:width .3s ease; background:#fff; box-shadow:0 0 8px rgba(255,255,255,0.5); }
    .legend{ display:flex; gap:20px; flex-wrap:wrap; justify-content:center; padding:16px; 
      background:rgba(255,255,255,0.4); border-radius:12px; margin-top:16px; }
    .legend-item{ display:flex; align-items:center; gap:8px; font-weight:700; font-size:13px; }
    .legend-dot{ width:16px; height:16px; border-radius:50%; border:3px solid #333; box-shadow:0 2px 8px rgba(0,0,0,0.3); }
    /* NEW for legend */
    .legend-line{ width:16px; height:8px; border-radius:4px; border:3px solid #333; box-shadow:0 2px 8px rgba(0,0,0,0.3); }
    .legend-rect{ width:16px; height:16px; border-radius:4px; border:3px solid #333; box-shadow:0 2px 8px rgba(0,0,0,0.3); }

    .tip{ padding:12px 16px; background:#fff3cd; border:2px solid #ffc107; border-radius:10px; 
      margin-top:12px; font-size:13px; font-weight:600; color:#856404; }
    .tip.info{ background:#d1ecf1; border-color:#17a2b8; color:#0c5460; }
    .tip.danger{ background:#f8d7da; border-color:#f5c6cb; color:#721c24; }
  </style>
</head>
<body>
  <h1>ğŸ¦… NEAT EVOLUTION: Build the Nest & Survive ğŸŒ³</h1>
  <canvas id="canvas" width="1800" height="900"></canvas>

  <div class="controls">
    <div class="top-bar">
      <div class="btn-group">
        <button class="btn" id="btnReset">ğŸ”„ New Simulation</button>
        <button class="btn secondary" id="btnPause">â¸ï¸ Pause</button>
        <a class="btn secondary" href="neat-guide.html">ğŸ“˜ NEAT Guide</a>
      </div>
      <div class="speed-control">
        <label for="speedSlider">Speed</label>
        <input type="range" id="speedSlider" min="1" max="50" value="1">
        <span class="speed-value" id="speedDisplay">1Ã—</span>
      </div>
      <div class="score-panel">
        <div class="score-item">
          <div class="score-label">Generation</div>
          <div class="score-value ok" id="genValue">1</div>
        </div>
        <div class="score-item">
          <div class="score-label">Survival Time</div>
          <div class="score-value" id="timeValue">0s</div>
        </div>
        <div class="score-item">
          <div class="score-label">ğŸ¦ Birds Alive</div>
          <div class="score-value ok" id="birdsAlive">0</div>
        </div>
        <div class="score-item">
          <div class="score-label">ğŸ’€ Deaths this Gen</div>
          <div class="score-value danger" id="deadThisGen">0</div>
        </div>
      </div>
    </div>

    <div class="legend">
      <div class="legend-item"><div class="legend-dot" style="background:#FFD700;"></div>Scout (Fast)</div>
      <div class="legend-item"><div class="legend-dot" style="background:#4CAF50;"></div>Thinker (Clever)</div>
      <div class="legend-item"><div class="legend-dot" style="background:#2196F3;"></div>Flocker (Social)</div>
      <div class="legend-item"><div class="legend-dot" style="background:#9C27B0;"></div>Predator (Immortal)</div>
      <div class="legend-item"><div class="legend-dot" style="background:#3ECF5B;"></div>Hide Spot</div>
      <div class="legend-item"><div class="legend-rect" style="background:#006400;"></div>Tree (Obstacle)</div>
      <div class="legend-item"><div class="legend-line" style="background:#D2691E;"></div>Twig</div>
      <div class="legend-item"><div class="legend-dot" style="background:#A0522D;"></div>Bird Nest</div>
    </div>

    <div class="tip info">
      ğŸŒ² <strong>NEW GOAL:</strong> The birds must now build a nest! Collect twigs from the pile in the middle of the
      arena and carry them to the nest in the upper left. Every twig grants a <strong>big fitness bonus!</strong>
      Trees are obstacles that everyone must fly around or above.
    </div>

    <div class="tip danger">
      âš ï¸ <strong>HIDE SPOTS:</strong> Birds can hide for a <strong>maximum of 3 seconds</strong> (180 frames),
      then they MUST leave for a <strong>5 second cooldown</strong>.
    </div>

    <div class="section">
      <div class="section-title collapsible" data-target="basic">âš™ï¸ Core Settings</div>
      <div id="basic" class="collapse-content">
        <div class="grid">
          <div class="control">
            <label>ğŸ¦ Total Small Birds</label>
            <input type="number" id="birdCount" value="30" min="9" max="90" step="3">
          </div>
          <div class="control">
            <label>ğŸ¦… Predator Count</label>
            <input type="range" id="predCount" min="0" max="8" value="0">
            <span class="chip danger" id="uiPredCount">0</span>
          </div>
          <div class="control">
            <label>ğŸ Food Spawn Rate</label>
            <input type="range" id="foodRate" min="1" max="20" value="8">
            <span class="chip" id="uiFoodRate">8</span>
          </div>
          <div class="control">
            <label>ğŸŒ³ Hide Spots Count</label>
            <input type="range" id="hideSpots" min="3" max="15" value="6">
            <span class="chip ok" id="uiHideSpots">6</span>
          </div>
          <div class="control">
            <label>ğŸ  Capacity per Hide Spot</label>
            <input type="range" id="hideCapacity" min="1" max="8" value="3">
            <span class="chip" id="uiHideCapacity">3</span>
          </div>
          <div class="control">
            <label>ğŸŒ² Trees (obstacles)</label>
            <input type="range" id="treeCount" min="0" max="15" value="0">
            <span class="chip warn" id="uiTreeCount">0</span>
          </div>
        </div>
      </div>
    </div>
    
    <div class="section">
      <div class="section-title collapsible" data-target="nest-build">ğŸ  Nest Building (New Objective!)</div>
      <div id="nest-build" class="collapse-content">
        <div class="grid">
          <div class="control">
            <label>ğŸªµ Twigs in the Pile</label>
            <input type="range" id="twigCount" min="10" max="200" value="50" step="10">
            <span class="chip" id="uiTwigCount">50</span>
          </div>
          <div class="control">
            <label>ğŸ† Fitness Bonus per Twig</label>
            <input type="range" id="twigBonus" min="500" max="10000" value="3000" step="100">
            <span class="chip ok" id="uiTwigBonus">3000</span>
          </div>
        </div>
      </div>
    </div>

    <div class="section">
      <div class="section-title collapsible collapsed" data-target="hide-settings">ğŸŒ³ Hide Spot Settings (Critical for Evolution!)</div>
      <div id="hide-settings" class="collapse-content hidden">
        <div class="grid">
          <div class="control">
            <label>â±ï¸ Max Hide Time (frames)</label>
            <input type="range" id="maxHideTime" min="20" max="300" value="180">
            <span class="chip warn" id="uiMaxHideTime">180 (~3s)</span>
          </div>
          <div class="control">
            <label>â³ Cooldown after Hiding (frames)</label>
            <input type="range" id="hideCooldown" min="60" max="1200" value="300">
            <span class="chip warn" id="uiHideCooldown">300 (~5s)</span>
          </div>
          <div class="control">
            <label>ğŸ˜° Fitness Penalty while Hiding</label>
            <input type="range" id="hidePenalty" min="0" max="20" value="2">
            <span class="chip warn" id="uiHidePenalty">-2</span>
          </div>
        </div>
      </div>
    </div>

    <div class="section">
      <div class="section-title collapsible collapsed" data-target="bird-evo">ğŸ§¬ Small Bird Evolution</div>
      <div id="bird-evo" class="collapse-content hidden">
        <div class="grid">
          <div class="control">
            <label>Elite % (top survivors kept)</label>
            <input type="range" id="birdElite" min="5" max="100" value="20">
            <span class="chip ok" id="uiBirdElite">20%</span>
          </div>
          <div class="control">
            <label>Parent Pool % (eligible to breed)</label>
            <input type="range" id="birdParent" min="20" max="80" value="50">
            <span class="chip ok" id="uiBirdParent">50%</span>
          </div>
          <div class="control">
            <label>Mutation Rate %</label>
            <input type="range" id="birdMutRate" min="5" max="50" value="15">
            <span class="chip ok" id="uiBirdMutRate">15%</span>
          </div>
          <div class="control">
            <label>Mutation Power</label>
            <input type="range" id="birdMutPower" min="10" max="80" value="35">
            <span class="chip ok" id="uiBirdMutPower">0.35</span>
          </div>
          <div class="control">
            <label>ğŸ§  Hidden Neurons</label>
            <input type="range" id="birdHidden" min="8" max="48" value="24">
            <span class="chip ok" id="uiBirdHidden">24</span>
          </div>
        </div>
      </div>
    </div>

    <div class="section">
      <div class="section-title collapsible collapsed" data-target="pred-evo">ğŸ¦… Predator Evolution</div>
      <div id="pred-evo" class="collapse-content hidden">
        <div class="grid">
          <div class="control">
            <label>Elite %</label>
            <input type="range" id="predElite" min="10" max="100" value="30">
            <span class="chip danger" id="uiPredElite">30%</span>
          </div>
          <div class="control">
            <label>Parent Pool %</label>
            <input type="range" id="predParent" min="30" max="90" value="60">
            <span class="chip danger" id="uiPredParent">60%</span>
          </div>
          <div class="control">
            <label>Mutation Rate %</label>
            <input type="range" id="predMutRate" min="5" max="50" value="20">
            <span class="chip danger" id="uiPredMutRate">20%</span>
          </div>
          <div class="control">
            <label>Mutation Power</label>
            <input type="range" id="predMutPower" min="10" max="80" value="30">
            <span class="chip danger" id="uiPredMutPower">0.30</span>
          </div>
          <div class="control">
            <label>ğŸ§  Hidden Neurons</label>
            <input type="range" id="predHidden" min="8" max="40" value="20">
            <span class="chip danger" id="uiPredHidden">20</span>
          </div>
        </div>
      </div>
    </div>

    <div class="section">
      <div class="section-title collapsible collapsed" data-target="balance">âš–ï¸ Balance & Behaviour</div>
      <div id="balance" class="collapse-content hidden">
        <div class="grid">
          <div class="control">
            <label>ğŸ’¨ Stamina Cost</label>
            <input type="range" id="staminaCost" min="1" max="15" value="2">
            <span class="chip" id="uiStaminaCost">2</span>
          </div>
          <div class="control">
            <label>ğŸ”‹ Energy per Movement</label>
            <input type="range" id="energyCost" min="1" max="20" value="3">
            <span class="chip" id="uiEnergyCost">0.03</span>
          </div>
          <div class="control">
            <label>ğŸš¨ Warning Boost %</label>
            <input type="range" id="warnBoost" min="0" max="100" value="30">
            <span class="chip" id="uiWarnBoost">30%</span>
          </div>
          <div class="control">
            <label>ğŸš¨ Alarm Radius</label>
            <input type="range" id="alarmRange" min="50" max="400" value="150">
            <span class="chip" id="uiAlarmRange">150</span>
          </div>
          <div class="control">
            <label>ğŸ Food Energy Value</label>
            <input type="range" id="foodValue" min="20" max="100" value="60">
            <span class="chip" id="uiFoodValue">60</span>
          </div>
        </div>
      </div>
    </div>

    <div class="section">
      <div class="section-title collapsible collapsed" data-target="pred-settings">ğŸ¦… Predator Settings</div>
      <div id="pred-settings" class="collapse-content hidden">
        <div class="grid">
          <div class="control">
            <label>âš¡ Hunt Speed</label>
            <input type="range" id="predSpeed" min="4" max="14" value="7">
            <span class="chip danger" id="uiPredSpeed">7</span>
          </div>
          <div class="control">
            <label>ğŸ”‹ Nest Charge Speed</label>
            <input type="range" id="nestCharge" min="1" max="15" value="5">
            <span class="chip danger" id="uiNestCharge">5</span>
          </div>
          <div class="control">
            <label>ğŸ– Energy per Capture</label>
            <input type="range" id="killEnergy" min="20" max="100" value="40">
            <span class="chip danger" id="uiKillEnergy">40</span>
          </div>
          <div class="control">
            <label>ğŸ’ª Fitness per Capture</label>
            <input type="range" id="killFitness" min="500" max="5000" step="100" value="3000">
            <span class="chip danger" id="uiKillFitness">3000</span>
          </div>
          <div class="control">
            <label>ğŸ“ˆ Progressive Evolution</label>
            <input type="checkbox" id="predEvolve" checked>
          </div>
          <div class="control">
            <label>ğŸ¯ Pack Hunting</label>
            <input type="checkbox" id="packHunt" checked>
          </div>
        </div>
      </div>
    </div>

    <div class="section">
      <div class="section-title">ğŸ“Š Live Statistics</div>
      <div class="stats-grid">
        <div class="stat-card">
          <div class="stat-label">âš¡ Scout</div>
          <div class="stat-value" id="scoutCount">0</div>
          <div class="bar"><div id="scoutBar"></div></div>
        </div>
        <div class="stat-card">
          <div class="stat-label">ğŸ§  Thinker</div>
          <div class="stat-value" id="thinkerCount">0</div>
          <div class="bar"><div id="thinkerBar"></div></div>
        </div>
        <div class="stat-card">
          <div class="stat-label">ğŸ¤ Flocker</div>
          <div class="stat-value" id="flockerCount">0</div>
          <div class="bar"><div id="flockerBar"></div></div>
        </div>
        <div class="stat-card">
          <div class="stat-label">ğŸªµ Twigs in Nest</div>
          <div class="stat-value" id="twigsInNest">0</div>
          <div class="bar"><div id="twigBar"></div></div>
        </div>
        <div class="stat-card">
          <div class="stat-label">ğŸ’€ Total Dead</div>
          <div class="stat-value" id="totalEaten">0</div>
        </div>
        <div class="stat-card">
          <div class="stat-label">ğŸ  Predators Charging</div>
          <div class="stat-value" id="predsCharging">0</div>
        </div>
        <div class="stat-card">
          <div class="stat-label">ğŸŒ³ In Hide Spots</div>
          <div class="stat-value" id="birdsHiding">0</div>
        </div>
        <div class="stat-card">
          <div class="stat-label">ğŸ Mat ute</div>
          <div class="stat-value" id="foodActive">0</div>
        </div>
      </div>
    </div>

    <div class="section">
      <div class="section-title">ğŸ† Records</div>
      <div class="stats-grid">
        <div class="stat-card">
          <div class="stat-label">â­ Highest Fitness</div>
          <div class="stat-value" id="recordBestFitness">0</div>
        </div>
        <div class="stat-card">
          <div class="stat-label">â±ï¸ Longest Life (s)</div>
          <div class="stat-value" id="recordLongestLife">0s</div>
        </div>
        <div class="stat-card">
          <div class="stat-label">ğŸª¹ Largest Nest</div>
          <div class="stat-value" id="recordLargestNest">0</div>
        </div>
        <div class="stat-card">
          <div class="stat-label">ğŸ’€ Most Birds Caught</div>
          <div class="stat-value" id="recordMostKills">0</div>
        </div>
      </div>
    </div>
  </div>

  <script>
    const clamp = (value, min = 0, max = 1) => Math.max(min, Math.min(max, value));

    // Config
    let BIRD_COUNT = 30;
    let PRED_COUNT = 0;
    let FOOD_SPAWN_RATE = 8;
    let HIDE_SPOT_COUNT = 6;
    let HIDE_CAPACITY = 3;
    let TREE_COUNT = 0; // NEW
    
    // NEW: Nest building
    let TWIG_PILE_COUNT = 50;
    let TWIG_FITNESS_BONUS = 3000;
    const TWIG_PICKUP_RATIO = 0.12;
    const TWIG_PROGRESS_FACTOR = 0.6;
    const TWIG_BACKTRACK_FACTOR = 0.3;
    const TWIG_IDLE_PENALTY = 2;
    const TWIG_IDLE_INTERVAL = 45;
    const TWIG_DEATH_RATIO = 0.3;
    
    // CRITICAL for evolution!
    let MAX_HIDE_TIME = 180; // Max 3 seconds in a hide spot (longer time to rest)
    let HIDE_COOLDOWN = 300; // 5 second cooldown (faster recovery)
    let HIDE_PENALTY = 2; // Smaller penalty for hiding
    
    // Bird evolution
    let BIRD_ELITE_RATE = 0.20;
    let BIRD_PARENT_POOL = 0.50;
    let BIRD_MUT_RATE = 0.15;
    let BIRD_MUT_POWER = 0.35;
    let BIRD_HIDDEN = 24;
    
    // Pred evolution
    let PRED_ELITE_RATE = 0.30;
    let PRED_PARENT_POOL = 0.60;
    let PRED_MUT_RATE = 0.20;
    let PRED_MUT_POWER = 0.30;
    let PRED_HIDDEN = 20;
    
    // Balance
    let STAMINA_COST = 2; // Less fatigue
    let ENERGY_MOVE_COST = 0.03; // Base energy cost per step
    let WARN_BOOST = 0.30;
    let ALARM_RANGE = 150;
    let FOOD_VALUE = 60; // More energy from food
    
    // Pred settings
    let PRED_SPEED = 7;
    let NEST_CHARGE_RATE = 5;
    let KILL_ENERGY = 40; // Less energy from catches (balanced with shorter bar)
    let KILL_FITNESS = 3000;
    let PRED_EVOLVE = true;
    let PACK_HUNT = true;
    
    let generation = 1;
    let globalTime = 0;
    let survivalTime = 0;
    let paused = false;
    let timeScale = 1;
    let totalEaten = 0;
    let deadThisGen = 0;
    let twigsInNest = 0; // NYTT
    
    let birds = [];
    let predators = [];
    let foodParticles = [];
    let hideSpots = [];
    let predNests = [];
    let particles = [];
    let alarmWaves = [];
    let trees = []; // NYTT
    let twigPile = []; // NYTT
    let birdNest = null; // NYTT
    let grassBlades = [];

    let recordBestFitness = 0;
    let recordLongestLife = 0;
    let recordLargestNest = 0;
    let recordMostKills = 0;

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const GROUND_Y = canvas.height - 50;
    const NEST_X = 140;
    const NEST_Y = GROUND_Y - 140;
    const TWIG_PILE_X = canvas.width / 2;
    const TWIG_PILE_Y = GROUND_Y - 10;
    const TWIG_PILE_WIDTH = 220;
    const TWIG_PILE_HEIGHT = 120;
    const INITIAL_FOOD_COUNT = 25;
    
    const BIRD_TYPES = {
      SCOUT: { color: '#FFD700', speed: 1.4, vision: 1.3, stamina: 0.8, name: 'Scout' },
      THINKER: { color: '#4CAF50', speed: 0.9, vision: 1.6, stamina: 1.2, name: 'Thinker' },
      FLOCKER: { color: '#2196F3', speed: 1.1, vision: 1.1, stamina: 1.0, name: 'Flocker' }
    };
    
    // Collapsible sections
    document.querySelectorAll('.collapsible').forEach(el => {
      el.addEventListener('click', () => {
        const target = document.getElementById(el.dataset.target);
        el.classList.toggle('collapsed');
        target.classList.toggle('hidden');
      });
    });
    
    // Event listeners
    const speedSlider = document.getElementById('speedSlider');
    const speedDisplay = document.getElementById('speedDisplay');
    const applySpeed = value => {
      const newScale = Math.max(1, Math.min(50, parseInt(value, 10) || 1));
      timeScale = newScale;
      speedDisplay.textContent = `${newScale}Ã—`;
    };

    applySpeed(speedSlider.value);

    document.getElementById('btnReset').addEventListener('click', () => resetSimulation());
    document.getElementById('btnPause').addEventListener('click', () => { paused = !paused; });
    speedSlider.addEventListener('input', e => applySpeed(e.target.value));
    
    // Basic settings
    document.getElementById('birdCount').addEventListener('change', e => {
      let v = parseInt(e.target.value);
      v = Math.floor(v / 3) * 3;
      BIRD_COUNT = Math.max(9, Math.min(90, v));
      e.target.value = BIRD_COUNT;
    });
    
    const syncPredatorCount = () => {
      if (PRED_COUNT <= 0) {
        predators = [];
        buildPredatorNests(0);
        return;
      }

      if (!predNests.length) {
        buildPredatorNests(PRED_COUNT);
      }

      if (predators.length > PRED_COUNT) {
        predators.length = PRED_COUNT;
      } else {
        while (predators.length < PRED_COUNT) {
          predators.push(new Predator());
        }
      }
    };

    document.getElementById('predCount').addEventListener('input', e => {
      PRED_COUNT = parseInt(e.target.value);
      document.getElementById('uiPredCount').textContent = PRED_COUNT;
      syncPredatorCount();
    });
    
    document.getElementById('foodRate').addEventListener('input', e => {
      FOOD_SPAWN_RATE = parseInt(e.target.value);
      document.getElementById('uiFoodRate').textContent = FOOD_SPAWN_RATE;
    });
    
    document.getElementById('hideSpots').addEventListener('input', e => {
      HIDE_SPOT_COUNT = parseInt(e.target.value);
      document.getElementById('uiHideSpots').textContent = HIDE_SPOT_COUNT;
    });
    
    document.getElementById('hideCapacity').addEventListener('input', e => {
      HIDE_CAPACITY = parseInt(e.target.value);
      document.getElementById('uiHideCapacity').textContent = HIDE_CAPACITY;
      hideSpots.forEach(h => h.capacity = HIDE_CAPACITY);
    });
    
    document.getElementById('treeCount').addEventListener('input', e => { // NYTT
      TREE_COUNT = parseInt(e.target.value);
      document.getElementById('uiTreeCount').textContent = TREE_COUNT;
    });
    
    // NYTT: Nest settings
    document.getElementById('twigCount').addEventListener('input', e => {
      TWIG_PILE_COUNT = parseInt(e.target.value);
      document.getElementById('uiTwigCount').textContent = TWIG_PILE_COUNT;
    });
    
    document.getElementById('twigBonus').addEventListener('input', e => {
      TWIG_FITNESS_BONUS = parseInt(e.target.value);
      document.getElementById('uiTwigBonus').textContent = TWIG_FITNESS_BONUS;
    });
    
    // Hide settings
    document.getElementById('maxHideTime').addEventListener('input', e => {
      MAX_HIDE_TIME = parseInt(e.target.value);
      const seconds = (MAX_HIDE_TIME / 60).toFixed(1);
      document.getElementById('uiMaxHideTime').textContent = `${MAX_HIDE_TIME} (~${seconds}s)`;
    });
    
    document.getElementById('hideCooldown').addEventListener('input', e => {
      HIDE_COOLDOWN = parseInt(e.target.value);
      const seconds = (HIDE_COOLDOWN / 60).toFixed(1);
      document.getElementById('uiHideCooldown').textContent = `${HIDE_COOLDOWN} (~${seconds}s)`;
    });
    
    document.getElementById('hidePenalty').addEventListener('input', e => {
      HIDE_PENALTY = parseInt(e.target.value);
      document.getElementById('uiHidePenalty').textContent = '-' + HIDE_PENALTY;
    });
    
    // Bird evolution
    document.getElementById('birdElite').addEventListener('input', e => {
      BIRD_ELITE_RATE = parseInt(e.target.value) / 100;
      document.getElementById('uiBirdElite').textContent = e.target.value + '%';
    });
    
    document.getElementById('birdParent').addEventListener('input', e => {
      BIRD_PARENT_POOL = parseInt(e.target.value) / 100;
      document.getElementById('uiBirdParent').textContent = e.target.value + '%';
    });
    
    document.getElementById('birdMutRate').addEventListener('input', e => {
      BIRD_MUT_RATE = parseInt(e.target.value) / 100;
      document.getElementById('uiBirdMutRate').textContent = e.target.value + '%';
    });
    
    document.getElementById('birdMutPower').addEventListener('input', e => {
      BIRD_MUT_POWER = parseInt(e.target.value) / 100;
      document.getElementById('uiBirdMutPower').textContent = (parseInt(e.target.value) / 100).toFixed(2);
    });
    
    document.getElementById('birdHidden').addEventListener('input', e => {
      BIRD_HIDDEN = parseInt(e.target.value);
      document.getElementById('uiBirdHidden').textContent = BIRD_HIDDEN;
    });
    
    // Pred evolution
    document.getElementById('predElite').addEventListener('input', e => {
      PRED_ELITE_RATE = parseInt(e.target.value) / 100;
      document.getElementById('uiPredElite').textContent = e.target.value + '%';
    });
    
    document.getElementById('predParent').addEventListener('input', e => {
      PRED_PARENT_POOL = parseInt(e.target.value) / 100;
      document.getElementById('uiPredParent').textContent = e.target.value + '%';
    });
    
    document.getElementById('predMutRate').addEventListener('input', e => {
      PRED_MUT_RATE = parseInt(e.target.value) / 100;
      document.getElementById('uiPredMutRate').textContent = e.target.value + '%';
    });
    
    document.getElementById('predMutPower').addEventListener('input', e => {
      PRED_MUT_POWER = parseInt(e.target.value) / 100;
      document.getElementById('uiPredMutPower').textContent = (parseInt(e.target.value) / 100).toFixed(2);
    });
    
    document.getElementById('predHidden').addEventListener('input', e => {
      PRED_HIDDEN = parseInt(e.target.value);
      document.getElementById('uiPredHidden').textContent = PRED_HIDDEN;
    });
    
    // Balance
    document.getElementById('staminaCost').addEventListener('input', e => {
      STAMINA_COST = parseInt(e.target.value);
      document.getElementById('uiStaminaCost').textContent = STAMINA_COST;
    });

    document.getElementById('energyCost').addEventListener('input', e => {
      const raw = parseInt(e.target.value);
      ENERGY_MOVE_COST = raw / 100;
      document.getElementById('uiEnergyCost').textContent = ENERGY_MOVE_COST.toFixed(2);
    });

    document.getElementById('uiEnergyCost').textContent = ENERGY_MOVE_COST.toFixed(2);

    document.getElementById('warnBoost').addEventListener('input', e => {
      WARN_BOOST = parseInt(e.target.value) / 100;
      document.getElementById('uiWarnBoost').textContent = e.target.value + '%';
    });
    
    document.getElementById('alarmRange').addEventListener('input', e => {
      ALARM_RANGE = parseInt(e.target.value);
      document.getElementById('uiAlarmRange').textContent = ALARM_RANGE;
    });
    
    document.getElementById('foodValue').addEventListener('input', e => {
      FOOD_VALUE = parseInt(e.target.value);
      document.getElementById('uiFoodValue').textContent = FOOD_VALUE;
    });
    
    // Pred settings
    document.getElementById('predSpeed').addEventListener('input', e => {
      PRED_SPEED = parseInt(e.target.value);
      document.getElementById('uiPredSpeed').textContent = PRED_SPEED;
    });
    
    document.getElementById('nestCharge').addEventListener('input', e => {
      NEST_CHARGE_RATE = parseInt(e.target.value);
      document.getElementById('uiNestCharge').textContent = NEST_CHARGE_RATE;
    });
    
    document.getElementById('killEnergy').addEventListener('input', e => {
      KILL_ENERGY = parseInt(e.target.value);
      document.getElementById('uiKillEnergy').textContent = KILL_ENERGY;
    });
    
    document.getElementById('killFitness').addEventListener('input', e => {
      KILL_FITNESS = parseInt(e.target.value);
      document.getElementById('uiKillFitness').textContent = KILL_FITNESS;
    });
    
    document.getElementById('predEvolve').addEventListener('change', e => {
      PRED_EVOLVE = e.target.checked;
    });
    
    document.getElementById('packHunt').addEventListener('change', e => {
      PACK_HUNT = e.target.checked;
    });
    
    // Classes
    class Particle {
      constructor(x, y, color, vx = 0, vy = 0) {
        this.x = x;
        this.y = y;
        this.vx = vx || (Math.random() - 0.5) * 4;
        this.vy = vy || (Math.random() - 0.5) * 4 - 2;
        this.color = color;
        this.size = 2 + Math.random() * 3;
        this.life = 30;
        this.maxLife = 30;
      }
      update() {
        this.x += this.vx;
        this.y += this.vy;
        this.vy += 0.15;
        this.vx *= 0.98;
        this.life--;
      }
      draw() {
        const alpha = clamp(this.life / this.maxLife);
        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
    }
    
    class AlarmWave {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.radius = 0;
        this.maxRadius = ALARM_RANGE;
        this.life = 40;
      }
      update() {
        this.radius += 6;
        this.life--;
      }
      draw() {
        const alpha = clamp(this.life / 40);
        ctx.save();
        ctx.globalAlpha = alpha * 0.3;
        ctx.strokeStyle = '#FF6B6B';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
      }
    }
    
    class FoodParticle {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.eaten = false;
        this.size = 6;
        this.pulse = Math.random() * Math.PI * 2;
      }
      update() {
        this.pulse += 0.1;
      }
      draw() {
        if (this.eaten) return;
        const s = this.size + Math.sin(this.pulse) * 2;
        ctx.fillStyle = '#8BC34A';
        ctx.beginPath();
        ctx.arc(this.x, this.y, s, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#689F38';
        ctx.lineWidth = 2;
        ctx.stroke();
      }
    }
    
    class HideSpot {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.radius = 50;
        this.capacity = HIDE_CAPACITY;
        this.occupants = [];
      }
      canHide() {
        return this.occupants.length < this.capacity;
      }
      addBird(bird) {
        if (this.canHide()) {
          this.occupants.push(bird);
          return true;
        }
        return false;
      }
      removeBird(bird) {
        const idx = this.occupants.indexOf(bird);
        if (idx >= 0) this.occupants.splice(idx, 1);
      }
      draw() {
        const ringWidth = 14;
        const ringRadius = this.radius - ringWidth / 2;

        ctx.save();

        // Glow
        const glowGrad = ctx.createRadialGradient(this.x, this.y, ringRadius * 0.3, this.x, this.y, ringRadius + ringWidth);
        glowGrad.addColorStop(0, 'rgba(142, 211, 123, 0.45)');
        glowGrad.addColorStop(1, 'rgba(142, 211, 123, 0)');
        ctx.fillStyle = glowGrad;
        ctx.beginPath();
        ctx.arc(this.x, this.y, ringRadius + ringWidth, 0, Math.PI * 2);
        ctx.fill();

        // Ring
        const ringGrad = ctx.createLinearGradient(this.x, this.y - ringRadius, this.x, this.y + ringRadius);
        ringGrad.addColorStop(0, '#3ecf5b');
        ringGrad.addColorStop(1, '#1f8f3c');
        ctx.strokeStyle = ringGrad;
        ctx.lineWidth = ringWidth;
        ctx.beginPath();
        ctx.arc(this.x, this.y, ringRadius, 0, Math.PI * 2);
        ctx.stroke();

        // Inner field
        const innerGrad = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, ringRadius * 0.75);
        innerGrad.addColorStop(0, 'rgba(26, 73, 37, 0.75)');
        innerGrad.addColorStop(1, 'rgba(26, 73, 37, 0.35)');
        ctx.fillStyle = innerGrad;
        ctx.beginPath();
        ctx.arc(this.x, this.y, ringRadius * 0.75, 0, Math.PI * 2);
        ctx.fill();

        // Icon
        ctx.fillStyle = '#d5f8d7';
        ctx.font = '28px "Segoe UI Emoji", "Apple Color Emoji", sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('ğŸ›¡ï¸', this.x, this.y - 6);

        // Capacity text
        ctx.fillStyle = 'rgba(255, 255, 255, 0.85)';
        ctx.font = 'bold 16px "Segoe UI", sans-serif';
        ctx.fillText(`${this.occupants.length}/${this.capacity}`, this.x, this.y + 20);

        ctx.restore();
      }
    }
    
    class PredatorNest {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.radius = 60;
      }
      draw() {
        ctx.fillStyle = '#3C2F2F';
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.strokeStyle = '#1C1C1C';
        ctx.lineWidth = 4;
        ctx.stroke();
        
        ctx.fillStyle = '#FF4444';
        ctx.font = 'bold 24px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('âš¡', this.x, this.y);
      }
    }
    
    // NEW: Tree class
    class Tree {
      constructor(x, width, height) {
        this.x = x;
        this.width = width;
        this.height = height;
        this.y = GROUND_Y - this.height;
        this.canopyRadius = this.width * 2.5;
        this.canopyCenterY = this.y - this.canopyRadius * 0.25;
        this.trunkColor = '#5D4037';
        this.canopyRingColor = `hsl(120, 55%, ${32 + Math.random() * 6}%)`;
        this.canopyCoreColor = `hsl(90, 50%, ${60 + Math.random() * 8}%)`;
        this.canopyOutlineColor = `hsl(120, 45%, ${24 + Math.random() * 6}%)`;
        this.ringWidth = this.canopyRadius * 0.55;
      }
      draw() {
        const centerX = this.x + this.width / 2;

        ctx.fillStyle = this.trunkColor;
        ctx.fillRect(this.x, this.y, this.width, this.height);

        ctx.strokeStyle = this.canopyRingColor;
        ctx.lineWidth = this.ringWidth;
        ctx.beginPath();
        ctx.arc(centerX, this.canopyCenterY, this.canopyRadius - this.ringWidth / 2, 0, Math.PI * 2);
        ctx.stroke();

        ctx.fillStyle = this.canopyCoreColor;
        ctx.beginPath();
        ctx.arc(centerX, this.canopyCenterY, this.canopyRadius * 0.35, 0, Math.PI * 2);
        ctx.fill();

        ctx.strokeStyle = this.canopyOutlineColor;
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.arc(centerX, this.canopyCenterY, this.canopyRadius - this.ringWidth / 2, 0, Math.PI * 2);
        ctx.stroke();
      }
    }
    
    // NEW: Twig class
    class Twig {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.carriedBy = null;
        this.angle = (Math.random() - 0.5) * 0.5;
        this.length = 25 + Math.random() * 20;
      }
      draw() {
        if (this.carriedBy) return; // Drawn by the bird

        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        ctx.strokeStyle = '#8B4513';
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(-this.length / 2, 0);
        ctx.lineTo(this.length / 2, 0);
        ctx.stroke();
        ctx.restore();
      }
    }
    
    // NEW: Bird nest class
    class BirdNest {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.radius = 60;
        this.twigs = 0;
        this.twigData = [];
      }
      addTwig() {
        this.twigs++;
        recordLargestNest = Math.max(recordLargestNest, this.twigs);
        this.twigData.push({
          offset: (Math.random() - 0.5) * 0.8,
          angle: (Math.random() - 0.5) * 0.6,
          length: 20 + Math.random() * 16
        });
      }
      draw() {
        const bodyWidth = this.radius * 1.3;
        const bodyHeight = this.radius * 1.6;
        const roofHeight = this.radius * 0.9;
        const bodyX = this.x - bodyWidth / 2;
        const bodyY = this.y - bodyHeight * 0.45;

        const poleWidth = bodyWidth * 0.18;
        const groundContactY = GROUND_Y;
        const poleHeight = Math.max(0, groundContactY - (bodyY + bodyHeight));

        // Shadow
        const shadowGrad = ctx.createLinearGradient(bodyX, bodyY - roofHeight, bodyX, bodyY + bodyHeight + poleHeight);
        shadowGrad.addColorStop(0, 'rgba(0,0,0,0.08)');
        shadowGrad.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = shadowGrad;
        ctx.fillRect(bodyX - 10, bodyY - roofHeight, bodyWidth + 20, bodyHeight + poleHeight + 20);

        // Pole
        ctx.fillStyle = '#8B5A2B';
        if (poleHeight > 0) {
          ctx.fillRect(this.x - poleWidth / 2, bodyY + bodyHeight, poleWidth, poleHeight);
        }

        // Body
        const corner = bodyWidth * 0.12;
        const bodyGradient = ctx.createLinearGradient(bodyX, bodyY, bodyX, bodyY + bodyHeight);
        bodyGradient.addColorStop(0, '#fdf9f3');
        bodyGradient.addColorStop(1, '#e1d4c2');

        ctx.beginPath();
        ctx.moveTo(bodyX, bodyY + corner);
        ctx.quadraticCurveTo(bodyX, bodyY, bodyX + corner, bodyY);
        ctx.lineTo(bodyX + bodyWidth - corner, bodyY);
        ctx.quadraticCurveTo(bodyX + bodyWidth, bodyY, bodyX + bodyWidth, bodyY + corner);
        ctx.lineTo(bodyX + bodyWidth, bodyY + bodyHeight - corner);
        ctx.quadraticCurveTo(bodyX + bodyWidth, bodyY + bodyHeight, bodyX + bodyWidth - corner, bodyY + bodyHeight);
        ctx.lineTo(bodyX + corner, bodyY + bodyHeight);
        ctx.quadraticCurveTo(bodyX, bodyY + bodyHeight, bodyX, bodyY + bodyHeight - corner);
        ctx.closePath();
        ctx.fillStyle = bodyGradient;
        ctx.fill();
        ctx.strokeStyle = 'rgba(120, 90, 60, 0.35)';
        ctx.lineWidth = 4;
        ctx.stroke();

        // Roof
        const roofLeft = bodyX - bodyWidth * 0.12;
        const roofRight = bodyX + bodyWidth + bodyWidth * 0.12;
        const roofTop = bodyY - roofHeight;
        const roofGradient = ctx.createLinearGradient(this.x, roofTop, this.x, bodyY);
        roofGradient.addColorStop(0, '#f1b24a');
        roofGradient.addColorStop(1, '#d9822b');
        ctx.beginPath();
        ctx.moveTo(this.x, roofTop);
        ctx.lineTo(roofLeft, bodyY + 6);
        ctx.lineTo(roofRight, bodyY + 6);
        ctx.closePath();
        ctx.fillStyle = roofGradient;
        ctx.fill();
        ctx.strokeStyle = 'rgba(130, 80, 25, 0.6)';
        ctx.lineWidth = 4;
        ctx.stroke();

        // Entrance
        const holeY = bodyY + bodyHeight * 0.42;
        const holeRadius = bodyWidth * 0.22;
        ctx.fillStyle = '#2f2a24';
        ctx.beginPath();
        ctx.arc(this.x, holeY, holeRadius, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = 'rgba(255,255,255,0.35)';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(this.x, holeY, holeRadius + 4, 0, Math.PI * 2);
        ctx.stroke();

        // Perch
        const perchY = bodyY + bodyHeight * 0.62;
        const perchWidth = bodyWidth * 0.55;
        ctx.fillStyle = '#b48248';
        ctx.fillRect(this.x - perchWidth / 2, perchY, perchWidth, 6);
        ctx.beginPath();
        ctx.arc(this.x + perchWidth / 2, perchY + 3, 3, 0, Math.PI * 2);
        ctx.fill();

        // Decorative twigs
        ctx.save();
        ctx.translate(this.x, bodyY + bodyHeight * 0.8);
        for (const twig of this.twigData) {
          ctx.save();
          ctx.translate(twig.offset * bodyWidth * 0.4, 0);
          ctx.rotate(twig.angle);
          ctx.strokeStyle = '#8a5a35';
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(-twig.length / 2, 0);
          ctx.lineTo(twig.length / 2, 0);
          ctx.stroke();
          ctx.restore();
        }
        ctx.restore();

        // Bricka med antal kvistar
        const badgeWidth = bodyWidth * 0.55;
        const badgeHeight = 26;
        const badgeX = this.x - badgeWidth / 2;
        const badgeY = bodyY + bodyHeight + 20;
        const badgeGrad = ctx.createLinearGradient(badgeX, badgeY, badgeX, badgeY + badgeHeight);
        badgeGrad.addColorStop(0, '#3b82f6');
        badgeGrad.addColorStop(1, '#2563eb');
        const drawBadgePath = () => {
          const r = 12;
          ctx.beginPath();
          ctx.moveTo(badgeX + r, badgeY);
          ctx.lineTo(badgeX + badgeWidth - r, badgeY);
          ctx.quadraticCurveTo(badgeX + badgeWidth, badgeY, badgeX + badgeWidth, badgeY + r);
          ctx.lineTo(badgeX + badgeWidth, badgeY + badgeHeight - r);
          ctx.quadraticCurveTo(badgeX + badgeWidth, badgeY + badgeHeight, badgeX + badgeWidth - r, badgeY + badgeHeight);
          ctx.lineTo(badgeX + r, badgeY + badgeHeight);
          ctx.quadraticCurveTo(badgeX, badgeY + badgeHeight, badgeX, badgeY + badgeHeight - r);
          ctx.lineTo(badgeX, badgeY + r);
          ctx.quadraticCurveTo(badgeX, badgeY, badgeX + r, badgeY);
          ctx.closePath();
        };

        ctx.fillStyle = badgeGrad;
        if (ctx.roundRect) {
          ctx.beginPath();
          ctx.roundRect(badgeX, badgeY, badgeWidth, badgeHeight, 12);
        } else {
          drawBadgePath();
        }
        ctx.fill();

        ctx.strokeStyle = 'rgba(255,255,255,0.25)';
        ctx.lineWidth = 2;
        if (ctx.roundRect) {
          ctx.beginPath();
          ctx.roundRect(badgeX, badgeY, badgeWidth, badgeHeight, 12);
        } else {
          drawBadgePath();
        }
        ctx.stroke();

        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 18px "Segoe UI", sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(`${this.twigs}`, this.x, badgeY + badgeHeight / 2);
      }
    }
    
    class Brain {
      constructor(inputs, hidden, outputs, weights) {
        this.inputs = inputs;
        this.hidden = hidden;
        this.outputs = outputs;
        if (weights) {
          this.wIH = weights.wIH.map(r => r.slice());
          this.wHO = weights.wHO.map(r => r.slice());
        } else {
          this.wIH = Array.from({length: hidden}, () => 
            Array.from({length: inputs}, () => Math.random() * 2 - 1));
          this.wHO = Array.from({length: outputs}, () => 
            Array.from({length: hidden}, () => Math.random() * 2 - 1));
        }
      }
      forward(inp) {
        const hid = this.wIH.map(row => Math.tanh(row.reduce((s, w, i) => s + w * inp[i], 0)));
        return this.wHO.map(row => Math.tanh(row.reduce((s, w, i) => s + w * hid[i], 0)));
      }
      copy() {
        return new Brain(this.inputs, this.hidden, this.outputs, {wIH: this.wIH, wHO: this.wHO});
      }
      mutate(rate, power) {
        const mut = arr => arr.forEach(row => row.forEach((v, i, a) => {
          if (Math.random() < rate) a[i] += (Math.random() * 2 - 1) * power;
        }));
        mut(this.wIH);
        mut(this.wHO);
      }
    }
    
    class Bird {
      constructor(type, brain) {
        this.type = type;
        this.typeData = BIRD_TYPES[type];
        // UPDATED Brain: 33 inputs, 4 outputs
        this.brain = brain || new Brain(33, BIRD_HIDDEN, 4);
        this.reset();
      }
      reset() {
        this.x = 200 + Math.random() * 400;
        this.y = 200 + Math.random() * 300;
        this.vx = 0;
        this.vy = 0;
        this.alive = true;
        this.energy = 200; // More starting energy
        this.maxEnergy = 200; // Higher max energy
        this.stamina = 100;
        this.maxStamina = 100;
        this.fitness = 0;
        this.hiding = false;
        this.hideSpot = null;
        this.hidingTime = 0;
        this.hideCooldown = 0;
        this.warned = false;
        this.age = 0;
        this.hasTwig = null; // NEW
        this.facing = 1; // NEW
        this.twigLastDist = null;
        this.twigCarryTime = 0;
        this.trail = [];
      }
      think() {
        if (!this.alive || this.hiding) return;
        
        let closestFood = null;
        let minFoodDist = Infinity;
        for (const f of foodParticles) {
          if (f.eaten) continue;
          const d = Math.hypot(this.x - f.x, this.y - f.y);
          if (d < minFoodDist) {
            minFoodDist = d;
            closestFood = f;
          }
        }
        
        let closestPred = null;
        let minPredDist = Infinity;
        for (const p of predators) {
          if (p.inNest) continue;
          const d = Math.hypot(this.x - p.x, this.y - p.y);
          if (d < minPredDist) {
            minPredDist = d;
            closestPred = p;
          }
        }
        
        let closestHide = null;
        let minHideDist = Infinity;
        for (const h of hideSpots) {
          if (!h.canHide()) continue;
          const d = Math.hypot(this.x - h.x, this.y - h.y);
          if (d < minHideDist) {
            minHideDist = d;
            closestHide = h;
          }
        }
        
        // NEW: Find nearest twig
        let closestTwig = null;
        let minTwigDist = Infinity;
        if (!this.hasTwig) {
          for (const t of twigPile) {
            if (t.carriedBy) continue;
            const d = Math.hypot(this.x - t.x, this.y - t.y);
            if (d < minTwigDist) {
              minTwigDist = d;
              closestTwig = t;
            }
          }
        }
        
        // NEW: Distance to nest
        const nestDist = Math.hypot(this.x - birdNest.x, this.y - birdNest.y);
        
        let nearbyBirds = 0;
        for (const b of birds) {
          if (b === this || !b.alive || b.hiding) continue;
          const d = Math.hypot(this.x - b.x, this.y - b.y);
          if (d < 100) nearbyBirds++;
        }
        
        this.warned = closestPred && minPredDist < ALARM_RANGE;

        const headingMag = Math.hypot(this.vx, this.vy);
        let dirX = this.vx;
        let dirY = this.vy;
        if (headingMag < 0.1) {
          dirX = this.facing;
          dirY = 0;
        }
        const dirLen = Math.hypot(dirX, dirY) || 1;
        const normDirX = dirX / dirLen;
        const normDirY = dirY / dirLen;
        const leftDirX = -normDirY;
        const leftDirY = normDirX;

        let frontTree = Infinity;
        let leftTree = Infinity;
        let rightTree = Infinity;
        for (const tree of trees) {
          const tx = tree.x + tree.width / 2;
          const ty = tree.y;
          const dx = tx - this.x;
          const dy = ty - this.y;
          const forward = dx * normDirX + dy * normDirY;
          const lateral = dx * leftDirX + dy * leftDirY;
          if (forward > 0 && forward < frontTree) frontTree = forward;
          if (lateral > 0 && lateral < leftTree) leftTree = lateral;
          if (lateral < 0 && -lateral < rightTree) rightTree = -lateral;
        }

        const normDist = d => (isFinite(d) ? Math.min(d / 400, 1) : 1);
        const frontTreeNorm = normDist(frontTree);
        const leftTreeNorm = normDist(leftTree);
        const rightTreeNorm = normDist(rightTree);
        const wallDist = Math.min(this.x, canvas.width - this.x, this.y, GROUND_Y - this.y);
        const wallDistNorm = normDist(wallDist);

        // UPPDATERAD: 33 inputs
        const inputs = [
          this.x / canvas.width,
          this.y / canvas.height,
          this.vx / 10,
          this.vy / 10,
          this.energy / this.maxEnergy,
          this.stamina / this.maxStamina,
          closestFood ? (closestFood.x - this.x) / canvas.width : 0,
          closestFood ? (closestFood.y - this.y) / canvas.height : 0,
          closestFood ? minFoodDist / 1000 : 1,
          closestPred ? (closestPred.x - this.x) / canvas.width : 0,
          closestPred ? (closestPred.y - this.y) / canvas.height : 0,
          closestPred ? minPredDist / 500 : 1,
          closestHide ? (closestHide.x - this.x) / canvas.width : 0,
          closestHide ? (closestHide.y - this.y) / canvas.height : 0,
          closestHide ? minHideDist / 500 : 1,
          nearbyBirds / 10,
          this.warned ? 1 : 0,
          this.hiding ? 1 : 0,
          this.hidingTime / MAX_HIDE_TIME,
          this.hideCooldown / HIDE_COOLDOWN,
          this.hideCooldown > 0 ? 1 : 0,
          this.age / 1000,
          // NYA INPUTS
          this.hasTwig ? 1 : 0, // 23
          closestTwig ? (closestTwig.x - this.x) / canvas.width : 0, // 24
          closestTwig ? (closestTwig.y - this.y) / canvas.height : 0, // 25
          closestTwig ? minTwigDist / 1000 : 1, // 26
          (birdNest.x - this.x) / canvas.width, // 27
          (birdNest.y - this.y) / canvas.height, // 28
          nestDist / 1000, // 29
          frontTreeNorm, // 30
          leftTreeNorm, // 31
          rightTreeNorm, // 32
          wallDistNorm // 33
        ];

        // UPDATED: 4 outputs
        const outputs = this.brain.forward(inputs);
        this.moveX = outputs[0];
        this.moveY = outputs[1];
        this.wantHide = outputs[2] > 0.3;
        this.wantTwig = outputs[3] > 0.3; // NEW
      }
      update() {
        if (!this.alive) return;

        if (!this.trail) this.trail = [];

        this.age++;
        recordLongestLife = Math.max(recordLongestLife, this.age);
        
        if (this.vx > 0.1) this.facing = 1;
        else if (this.vx < -0.1) this.facing = -1;
        
        // Cooldown counter
        if (this.hideCooldown > 0) {
          this.hideCooldown--;
        }
        
        // Hide spot logic
        if (this.hiding) {
          this.trail = [];
          this.hidingTime++;
          this.energy = Math.min(this.energy + 1.5, this.maxEnergy); 
          this.stamina = Math.min(this.stamina + 3, this.maxStamina);
          this.fitness -= HIDE_PENALTY * 0.1;
          
          if (this.hidingTime >= MAX_HIDE_TIME) {
            this.hiding = false;
            if (this.hideSpot) {
              this.hideSpot.removeBird(this);
              this.hideSpot = null;
            }
            this.hidingTime = 0;
            this.hideCooldown = HIDE_COOLDOWN;
          }
          return;
        }
        
        // NEW: Twig logic
        if (this.hasTwig) {
          // Fly to the nest
          const distToNest = Math.hypot(this.x - birdNest.x, this.y - birdNest.y);
          if (this.twigLastDist === null) {
            this.twigLastDist = distToNest;
          } else {
            const progress = this.twigLastDist - distToNest;
            if (progress > 0) {
              this.fitness += progress * TWIG_PROGRESS_FACTOR;
            } else if (progress < 0) {
              this.fitness += progress * TWIG_BACKTRACK_FACTOR;
            }
          }
          this.twigCarryTime++;
          if (this.twigCarryTime > 0 && this.twigCarryTime % TWIG_IDLE_INTERVAL === 0) {
            this.fitness -= TWIG_IDLE_PENALTY;
          }
          this.twigLastDist = distToNest;

          if (distToNest < birdNest.radius + 15) {
            // Twig delivered!
            birdNest.addTwig();
            if (this.hasTwig) this.hasTwig.carriedBy = null;
            twigPile = twigPile.filter(t => t !== this.hasTwig); // Remove the twig permanently
            this.hasTwig = null;
            this.twigLastDist = null;
            this.twigCarryTime = 0;
            this.fitness += TWIG_FITNESS_BONUS;
            twigsInNest++;
            recordLargestNest = Math.max(recordLargestNest, twigsInNest);
          }
        } else if (this.wantTwig && this.hideCooldown === 0) {
          // Try to pick up a twig
          for (const t of twigPile) {
            if (!t.carriedBy && Math.hypot(this.x - t.x, this.y - t.y) < 35) {
              this.hasTwig = t;
              t.carriedBy = this;
              this.twigLastDist = Math.hypot(this.x - birdNest.x, this.y - birdNest.y);
              this.twigCarryTime = 0;
              this.fitness += TWIG_FITNESS_BONUS * TWIG_PICKUP_RATIO;
              break;
            }
          }
        }

        // Try to hide IF the cooldown is over (and we're not carrying a twig?)
        // Birds carrying twigs might not want to hide? Let the brain decide.
        if (this.wantHide && this.hideCooldown === 0 && !this.hasTwig) {
          for (const h of hideSpots) {
            const d = Math.hypot(this.x - h.x, this.y - h.y);
            if (d < h.radius + 10 && h.canHide()) {
              if (h.addBird(this)) {
                this.hiding = true;
                this.hideSpot = h;
                this.x = h.x;
                this.y = h.y;
                this.trail = [];
                return;
              }
            }
          }
        }
        
        this.energy -= ENERGY_MOVE_COST;
        this.stamina -= STAMINA_COST * 0.05;
        
        let speedMult = this.typeData.speed;
        const grounded = this.y >= GROUND_Y - 2 && Math.abs(this.vy) < 1.2;
        if (grounded) speedMult *= 0.35;
        if (this.stamina < 20) speedMult *= 0.5;
        if (this.warned) speedMult *= (1 + WARN_BOOST);
        if (this.hasTwig) speedMult *= 0.8; // Slower with a twig
        
        this.vx += this.moveX * 0.7 * speedMult;
        this.vy += this.moveY * 0.7 * speedMult;
        
        const moveSpeed = Math.hypot(this.vx, this.vy);
        if (moveSpeed > 5) {
          this.stamina -= STAMINA_COST * 0.1;
          this.energy -= ENERGY_MOVE_COST * 0.5;
        }
        
        this.vy += 0.2;
        this.vx *= 0.97;
        this.vy *= 0.97;
        
        const maxSpeed = 8 * speedMult;
        const speed = Math.hypot(this.vx, this.vy);
        if (speed > maxSpeed) {
          this.vx = (this.vx / speed) * maxSpeed;
          this.vy = (this.vy / speed) * maxSpeed;
        }
        
        this.x += this.vx;
        this.y += this.vy;
        
        // Wall collision
        if (this.x < 0) { this.x = 0; this.vx = Math.abs(this.vx); }
        if (this.x > canvas.width) { this.x = canvas.width; this.vx = -Math.abs(this.vx); }
        if (this.y < 0) { this.y = 0; this.vy = Math.abs(this.vy); }
        if (this.y > GROUND_Y) { this.y = GROUND_Y; this.vy = -Math.abs(this.vy) * 0.6; }
        
        // NEW: Tree collision
        for (const tree of trees) {
          const birdRadiusX = 8;
          const birdRadiusY = 6;
          if (this.x + birdRadiusX > tree.x &&
              this.x - birdRadiusX < tree.x + tree.width &&
              this.y + birdRadiusY > tree.y) {
            
            // Colliding. Check if we hit the top
            if (this.y - birdRadiusY < tree.y && this.vy > 0) {
              this.y = tree.y - birdRadiusY;
              this.vy = -Math.abs(this.vy) * 0.3; // Bounce off the top
            } else { // Hit the side
              if (this.vx > 0) { // Moving right
                this.x = tree.x - birdRadiusX;
                this.vx = -Math.abs(this.vx) * 0.5;
              } else { // Moving left
                this.x = tree.x + tree.width + birdRadiusX;
                this.vx = Math.abs(this.vx) * 0.5;
              }
            }
          }
        }

        if (this.trail.length > 25) {
          this.trail.shift();
        }
        this.trail.push({ x: this.x, y: this.y });

        // Food collision
        for (const f of foodParticles) {
          if (f.eaten) continue;
          const d = Math.hypot(this.x - f.x, this.y - f.y);
          if (d < 15) {
            f.eaten = true;
            this.energy = Math.min(this.energy + FOOD_VALUE, this.maxEnergy);
            for (let i = 0; i < 5; i++) {
              particles.push(new Particle(f.x, f.y, '#8BC34A'));
            }
          }
        }
        
        if (this.alive) {
          this.fitness += 1;
          this.fitness += (this.energy / this.maxEnergy) * 0.3;
          if (!this.hiding) this.fitness += 0.5;
          
          const margin = 30;
          const notTouchingWalls = this.x > margin && this.x < canvas.width - margin && 
                                   this.y > margin && this.y < GROUND_Y - margin;
          if (notTouchingWalls) {
            this.fitness += 5;
          }
          
          let nearby = 0;
          for (const b of birds) {
            if (b === this || !b.alive || b.hiding) continue;
            if (Math.hypot(this.x - b.x, this.y - b.y) < 80) nearby++;
          }
          this.fitness += nearby * this.typeData.stamina * 0.1;
        }
        
        if (this.energy <= 0 || this.stamina <= 0) {
          this.alive = false;
          this.fitness = Math.max(0, this.fitness - 400);
          if (this.hasTwig) { // Drop twig on death
            this.fitness = Math.max(0, this.fitness - TWIG_FITNESS_BONUS * TWIG_DEATH_RATIO);
            this.hasTwig.carriedBy = null;
            this.hasTwig = null;
            this.twigLastDist = null;
            this.twigCarryTime = 0;
          }
          this.trail = [];
        }
        
        if (this.warned && globalTime % 30 === 0) {
          alarmWaves.push(new AlarmWave(this.x, this.y));
        }

        recordBestFitness = Math.max(recordBestFitness, this.fitness);
      }
      draw() {
        if (this.trail && this.trail.length > 1) {
          ctx.save();
          ctx.lineWidth = 3;
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';
          for (let i = 1; i < this.trail.length; i++) {
            const prev = this.trail[i - 1];
            const curr = this.trail[i];
            const alpha = i / this.trail.length;
            ctx.strokeStyle = this.typeData.color;
            ctx.globalAlpha = alpha * 0.45;
            ctx.beginPath();
            ctx.moveTo(prev.x, prev.y);
            ctx.lineTo(curr.x, curr.y);
            ctx.stroke();
          }
          ctx.restore();
        }

        if (!this.alive || this.hiding) return;

        ctx.save();
        ctx.translate(this.x, this.y);
        
        if (this.facing < 0) ctx.scale(-1, 1);
        
        if (this.warned) {
          ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(0, 0, 18, 0, Math.PI * 2);
          ctx.stroke();
        }
        
        if (this.hideCooldown > 0) {
          const cooldownPct = clamp(this.hideCooldown / HIDE_COOLDOWN);
          ctx.strokeStyle = `rgba(255, 100, 100, ${cooldownPct})`;
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.arc(0, 0, 15, 0, Math.PI * 2);
          ctx.stroke();
        }
        
        ctx.fillStyle = 'rgba(0,0,0,0.2)';
        ctx.beginPath();
        ctx.ellipse(0, 10, 8, 3, 0, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = this.typeData.color;
        ctx.beginPath();
        ctx.ellipse(0, 0, 9, 6, 0, 0, Math.PI * 2);
        ctx.fill();
        
        const flap = Math.sin(this.age * 0.25) * 0.4;
        ctx.save();
        ctx.rotate(flap);
        ctx.fillStyle = this.typeData.color;
        ctx.fillRect(-10, -2, 6, 2);
        ctx.restore();
        
        ctx.save();
        ctx.rotate(-flap);
        ctx.fillStyle = this.typeData.color;
        ctx.fillRect(4, -2, 6, 2);
        ctx.restore();
        
        ctx.fillStyle = this.typeData.color;
        ctx.beginPath();
        ctx.arc(6, -2, 3.5, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = this.warned ? '#FF0000' : '#000';
        ctx.beginPath();
        ctx.arc(7, -2.5, 1, 0, Math.PI * 2);
        ctx.fill();
        
        // NYTT: Rita kvist
        if (this.hasTwig) {
          ctx.strokeStyle = '#8B4513';
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(8, -1);
          ctx.lineTo(20, 0);
          ctx.stroke();
        }
        
        const ep = clamp(this.energy / this.maxEnergy);
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.fillRect(-9, -12, 18, 2);
        ctx.fillStyle = ep > 0.5 ? '#4CAF50' : ep > 0.25 ? '#FFA500' : '#FF4444';
        ctx.fillRect(-9, -12, 18 * ep, 2);

        const sp = clamp(this.stamina / this.maxStamina);
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.fillRect(-9, -15, 18, 2);
        ctx.fillStyle = sp > 0.5 ? '#2196F3' : sp > 0.25 ? '#FFA500' : '#FF4444';
        ctx.fillRect(-9, -15, 18 * sp, 2);
        
        ctx.restore();
      }
    }
    
    class Predator {
      constructor(brain) {
        this.brain = brain || new Brain(20, PRED_HIDDEN, 3);
        this.reset();
      }
      reset() {
        const nest = predNests.length
          ? predNests[Math.floor(Math.random() * predNests.length)]
          : { x: canvas.width - 220, y: 160, radius: 60 };
        this.x = nest.x;
        this.y = nest.y;
        this.homeNest = nest;
        this.vx = 0;
        this.vy = 0;
        this.inNest = true;
        this.energy = 30;
        this.maxEnergy = 60;
        this.fitness = 0;
        this.kills = 0;
        this.nestTime = 0;
        this.huntBonus = 0;
        this.facing = -1; // NYTT
        this.prevTargetDist = null;
        this.prevNestDist = null;
      }
      update() {
        if (this.vx > 0.1) this.facing = 1;
        else if (this.vx < -0.1) this.facing = -1;

        if (this.inNest) {
          this.nestTime++;
          this.energy = Math.min(this.energy + NEST_CHARGE_RATE, this.maxEnergy);
          this.prevTargetDist = null;
          this.prevNestDist = null;

          if (this.energy >= this.maxEnergy && this.nestTime > 20) {
            this.inNest = false;
            this.nestTime = 0;
          }
          return;
        }
        
        this.energy -= 0.6;
        
        let target = null;
        let minDist = Infinity;
        for (const b of birds) {
          if (!b.alive || b.hiding) continue;
          const d = Math.hypot(this.x - b.x, this.y - b.y);
          if (d < minDist) {
            minDist = d;
            target = b;
          }
        }

        const previousTargetDist = target ? (this.prevTargetDist ?? minDist) : null;

        let packMates = 0;
        if (PACK_HUNT && target) {
          for (const p of predators) {
            if (p === this || p.inNest) continue;
            const d = Math.hypot(this.x - p.x, this.y - p.y);
            if (d < 200) packMates++;
          }
        }

        const distToNest = Math.hypot(this.x - this.homeNest.x, this.y - this.homeNest.y);
        const previousNestDist = this.prevNestDist ?? distToNest;

        const headingMag = Math.hypot(this.vx, this.vy);
        let dirX = this.vx;
        let dirY = this.vy;
        if (headingMag < 0.1) {
          if (target) {
            dirX = target.x - this.x;
            dirY = target.y - this.y;
          } else {
            dirX = this.facing;
            dirY = 0;
          }
        }
        const dirLen = Math.hypot(dirX, dirY) || 1;
        const normDirX = dirX / dirLen;
        const normDirY = dirY / dirLen;
        const leftDirX = -normDirY;
        const leftDirY = normDirX;

        let frontTree = Infinity;
        let leftTree = Infinity;
        let rightTree = Infinity;
        for (const tree of trees) {
          const tx = tree.x + tree.width / 2;
          const ty = tree.y;
          const dx = tx - this.x;
          const dy = ty - this.y;
          const forward = dx * normDirX + dy * normDirY;
          const lateral = dx * leftDirX + dy * leftDirY;
          if (forward > 0 && forward < frontTree) frontTree = forward;
          if (lateral > 0 && lateral < leftTree) leftTree = lateral;
          if (lateral < 0 && -lateral < rightTree) rightTree = -lateral;
        }

        const normTree = d => (isFinite(d) ? Math.min(d / 500, 1) : 1);
        const frontTreeNorm = normTree(frontTree);
        const leftTreeNorm = normTree(leftTree);
        const rightTreeNorm = normTree(rightTree);
        const wallDist = Math.min(this.x, canvas.width - this.x, this.y, GROUND_Y - this.y);
        const wallDistNorm = normTree(wallDist);

        const inputs = [
          this.x / canvas.width,
          this.y / canvas.height,
          this.vx / 10,
          this.vy / 10,
          this.energy / this.maxEnergy,
          target ? (target.x - this.x) / canvas.width : 0,
          target ? (target.y - this.y) / canvas.height : 0,
          target ? minDist / 1000 : 1,
          (this.homeNest.x - this.x) / canvas.width,
          (this.homeNest.y - this.y) / canvas.height,
          distToNest / 1000,
          this.kills / 10,
          packMates / 5,
          birds.filter(b => b.alive && !b.hiding).length / BIRD_COUNT,
          this.inNest ? 1 : 0,
          this.huntBonus,
          frontTreeNorm,
          leftTreeNorm,
          rightTreeNorm,
          wallDistNorm
        ];
        
        const outputs = this.brain.forward(inputs);
        
        const evolutionBonus = PRED_EVOLVE ? (1 + this.huntBonus * 0.1) : 1;
        const packBonus = PACK_HUNT ? (1 + packMates * 0.1) : 1;
        const moveX = outputs[0] * 0.8 * evolutionBonus * packBonus;
        const moveY = outputs[1] * 0.8 * evolutionBonus * packBonus;
        const wantNest = outputs[2] > 0.4;
        
        this.vx += moveX;
        this.vy += moveY;
        this.vx *= 0.96;
        this.vy *= 0.96;
        
        const maxSpeed = PRED_SPEED * evolutionBonus * packBonus;
        const speed = Math.hypot(this.vx, this.vy);
        if (speed > maxSpeed) {
          this.vx = (this.vx / speed) * maxSpeed;
          this.vy = (this.vy / speed) * maxSpeed;
        }
        
        this.x += this.vx;
        this.y += this.vy;
        
        if (this.x < 0) { this.x = 10; this.vx = Math.abs(this.vx) * 0.5; this.energy -= 25; this.fitness -= 15; }
        if (this.x > canvas.width) { this.x = canvas.width - 10; this.vx = -Math.abs(this.vx) * 0.5; this.energy -= 25; this.fitness -= 15; }
        if (this.y < 0) { this.y = 10; this.vy = Math.abs(this.vy) * 0.5; this.energy -= 25; this.fitness -= 15; }
        if (this.y > GROUND_Y) { this.y = GROUND_Y - 10; this.vy = -Math.abs(this.vy) * 0.5; this.energy -= 25; this.fitness -= 15; }

        // NEW: Tree collision for predator
        for (const tree of trees) {
          const predRadiusX = 16;
          const predRadiusY = 10;
          if (this.x + predRadiusX > tree.x && 
              this.x - predRadiusX < tree.x + tree.width && 
              this.y + predRadiusY > tree.y) {
            
            if (this.y - predRadiusY < tree.y && this.vy > 0) {
              this.y = tree.y - predRadiusY;
              this.vy = -Math.abs(this.vy) * 0.3;
              this.fitness -= 8;
            } else {
              if (this.vx > 0) {
                this.x = tree.x - predRadiusX;
                this.vx = -Math.abs(this.vx) * 0.5;
                this.fitness -= 8;
              } else {
                this.x = tree.x + tree.width + predRadiusX;
                this.vx = Math.abs(this.vx) * 0.5;
                this.fitness -= 8;
              }
            }
          }
        }

        const newTargetDist = target ? Math.hypot(this.x - target.x, this.y - target.y) : null;
        if (previousTargetDist !== null && newTargetDist !== null) {
          const chaseDelta = previousTargetDist - newTargetDist;
          if (chaseDelta > 0) {
            this.fitness += chaseDelta * 0.4;
          } else if (chaseDelta < 0) {
            this.fitness += chaseDelta * 0.2;
          }
        } else if (!target) {
          if (birds.some(b => b.alive && !b.hiding)) {
            this.fitness -= 0.4;
          }
        }

        const updatedNestDist = Math.hypot(this.x - this.homeNest.x, this.y - this.homeNest.y);
        const nestDelta = previousNestDist - updatedNestDist;
        if (wantNest || this.energy < this.maxEnergy * 0.35) {
          if (nestDelta > 0) {
            this.fitness += nestDelta * 0.2;
          } else if (nestDelta < 0) {
            this.fitness += nestDelta * 0.1;
          }
        }

        if (target && newTargetDist !== null && newTargetDist < 180) {
          this.fitness += 1.5;
        }

        if (target && newTargetDist !== null && newTargetDist > 320) {
          this.fitness -= 0.3;
        }

        this.prevNestDist = updatedNestDist;

        for (const b of birds) {
          if (!b.alive || b.hiding) continue;
          const d = Math.hypot(this.x - b.x, this.y - b.y);
          if (d < 18) {
            b.alive = false;
            b.trail = [];
            if (b.hasTwig) { // Drop twig on death
              b.fitness = Math.max(0, b.fitness - TWIG_FITNESS_BONUS * TWIG_DEATH_RATIO);
              b.hasTwig.carriedBy = null;
              b.hasTwig = null;
              b.twigLastDist = null;
              b.twigCarryTime = 0;
            }
            this.energy = Math.min(this.energy + KILL_ENERGY, this.maxEnergy);
            this.fitness += KILL_FITNESS;
            this.kills++;
            recordMostKills = Math.max(recordMostKills, this.kills);
            totalEaten++;
            deadThisGen++;
            
            if (PRED_EVOLVE) {
              this.huntBonus += 0.05;
            }
            
            for (let i = 0; i < 20; i++) {
              particles.push(new Particle(b.x, b.y, b.typeData.color));
            }
          }
        }

        this.prevTargetDist = (target && target.alive) ? Math.hypot(this.x - target.x, this.y - target.y) : null;
        
        if (wantNest || this.energy < this.maxEnergy * 0.5) { 
          if (distToNest < this.homeNest.radius) {
            this.inNest = true;
            this.x = this.homeNest.x;
            this.y = this.homeNest.y;
            this.vx = 0;
            this.vy = 0;
          }
        }
      }
      
      // NYTT: drawInNest
      drawInNest() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.globalAlpha = 0.6; // Halvgenomskinlig
        
        if (this.facing < 0) ctx.scale(-1, 1);
        
        // Simplified body
        ctx.fillStyle = '#9C27B0';
        ctx.beginPath();
        ctx.ellipse(0, 0, 16, 10, 0, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = '#7B1FA2';
        ctx.beginPath();
        ctx.arc(10, -3, 5, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = '#FF0000';
        ctx.beginPath();
        ctx.arc(12, -4, 2.5, 0, Math.PI * 2);
        ctx.fill();
        
        // Energibar
        const ep = clamp(this.energy / this.maxEnergy);
        ctx.fillStyle = 'rgba(0,0,0,0.4)';
        ctx.fillRect(-9, -18, 18, 3);
        ctx.fillStyle = ep > 0.95 ? '#4CAF50' : ep > 0.25 ? '#FFA500' : '#FF4444';
        ctx.fillRect(-9, -18, 18 * ep, 3);
        
        ctx.restore();
      }
      
      draw() {
        // UPPDATERAD: Rita i boet
        if (this.inNest) {
          this.drawInNest();
          return;
        }
        
        ctx.save();
        ctx.translate(this.x, this.y);
        
        if (this.facing < 0) ctx.scale(-1, 1);
        
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath();
        ctx.ellipse(0, 14, 12, 4, 0, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = '#9C27B0';
        ctx.beginPath();
        ctx.ellipse(0, 0, 16, 10, 0, 0, Math.PI * 2);
        ctx.fill();
        
        const flap = Math.sin(globalTime * 0.3) * 0.5;
        ctx.save();
        ctx.rotate(flap);
        ctx.fillStyle = '#BA68C8';
        ctx.fillRect(-18, -3, 10, 3);
        ctx.restore();
        
        ctx.save();
        ctx.rotate(-flap);
        ctx.fillStyle = '#BA68C8';
        ctx.fillRect(8, -3, 10, 3);
        ctx.restore();
        
        ctx.fillStyle = '#7B1FA2';
        ctx.beginPath();
        ctx.arc(10, -3, 5, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = '#FF0000';
        ctx.beginPath();
        ctx.arc(12, -4, 2.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(12, -4, 1, 0, Math.PI * 2);
        ctx.fill();
        
        const ep = clamp(this.energy / this.maxEnergy);
        ctx.fillStyle = 'rgba(0,0,0,0.4)';
        ctx.fillRect(-9, -18, 18, 3);
        ctx.fillStyle = ep > 0.5 ? '#4CAF50' : ep > 0.25 ? '#FFA500' : '#FF4444';
        ctx.fillRect(-9, -18, 18 * ep, 3);
        
        if (this.kills > 0) {
          ctx.fillStyle = '#FFD700';
          ctx.font = 'bold 10px Arial';
          ctx.textAlign = 'center';
          ctx.fillText(`${this.kills}`, 0, -23);
        }
        
        ctx.restore();
      }
    }
    
    function buildPredatorNests(count) {
      predNests = [];
      if (count <= 0) return;

      const nestCenterX = canvas.width - 220;
      const nestOffsetX = 90;
      const nestStartY = 160;
      const nestSpacingY = 200;
      let nestsPlaced = 0;
      let row = 0;

      while (nestsPlaced < count) {
        const remaining = count - nestsPlaced;
        const y = nestStartY + row * nestSpacingY;
        if (remaining === 1) {
          predNests.push(new PredatorNest(nestCenterX, y));
          nestsPlaced += 1;
        } else {
          predNests.push(new PredatorNest(nestCenterX - nestOffsetX, y));
          if (nestsPlaced + 1 < count) {
            predNests.push(new PredatorNest(nestCenterX + nestOffsetX, y));
            nestsPlaced += 2;
          } else {
            nestsPlaced += 1;
          }
        }
        row++;
      }
    }

    // Init functions
    function initEnvironment() {
      hideSpots = [];
      const hidePositions = [
        {x: 250, y: 200}, {x: 400, y: 350}, {x: 200, y: 500},
        {x: 550, y: 250}, {x: 650, y: 450}, {x: 450, y: 600},
        {x: 350, y: 700}, {x: 800, y: 300}, {x: 900, y: 550},
        {x: 750, y: 700}, {x: 300, y: 400}, {x: 600, y: 650},
        {x: 500, y: 150}, {x: 700, y: 200}, {x: 850, y: 450}
      ];
      for (let i = 0; i < HIDE_SPOT_COUNT; i++) {
        const pos = hidePositions[i % hidePositions.length];
        hideSpots.push(new HideSpot(pos.x, pos.y));
      }
      buildPredatorNests(PRED_COUNT);
      
      // NEW: Init Trees
      trees = [];
      for (let i = 0; i < TREE_COUNT; i++) {
        const treeWidth = 25 + Math.random() * 20;
        const treeHeight = 150 + Math.random() * 300;
        // Undvik kanter och fiendebon
        const x = 200 + Math.random() * (canvas.width - 600); 
        trees.push(new Tree(x, treeWidth, treeHeight));
      }
      
      // NYTT: Init Bo & Kvistar
      birdNest = new BirdNest(NEST_X, NEST_Y); // Bottom left
      twigPile = [];
      const pileX = TWIG_PILE_X;
      const pileY = TWIG_PILE_Y;
      for (let i = 0; i < TWIG_PILE_COUNT; i++) {
        const offsetX = (Math.random() - 0.5) * TWIG_PILE_WIDTH;
        const heightFactor = Math.random();
        const twigY = pileY - heightFactor * TWIG_PILE_HEIGHT;
        twigPile.push(new Twig(pileX + offsetX * (0.7 + 0.3 * heightFactor), twigY));
      }
      twigsInNest = 0;

      grassBlades = [];
      for (let x = 0; x < canvas.width; x += 6) {
        grassBlades.push({
          x,
          width: 3 + Math.random() * 2,
          height: 8 + Math.random() * 12
        });
      }

      seedInitialFood();
    }
    
    function initBirds() {
      birds = [];
      const perType = BIRD_COUNT / 3;
      
      // Brain now created with the correct number of inputs/outputs in the constructor
      for (let i = 0; i < perType; i++) birds.push(new Bird('SCOUT'));
      for (let i = 0; i < perType; i++) birds.push(new Bird('THINKER'));
      for (let i = 0; i < perType; i++) birds.push(new Bird('FLOCKER'));
    }
    
    function initPredators() {
      predators = [];
      for (let i = 0; i < PRED_COUNT; i++) {
        predators.push(new Predator());
      }
    }

    function spawnFood() {
      if (Math.random() < FOOD_SPAWN_RATE * 0.01) {
        const x = 100 + Math.random() * (canvas.width - 200);
        const y = 100 + Math.random() * (GROUND_Y - 200);
        foodParticles.push(new FoodParticle(x, y));
      }
    }

    function seedInitialFood(count = INITIAL_FOOD_COUNT) {
      for (let i = 0; i < count; i++) {
        const x = 120 + Math.random() * (canvas.width - 240);
        const y = 120 + Math.random() * (GROUND_Y - 240);
        foodParticles.push(new FoodParticle(x, y));
      }
    }
    
    function evolveBirds() {
      const types = ['SCOUT', 'THINKER', 'FLOCKER'];
      const newBirds = [];
      
      for (const type of types) {
        const typeBirds = birds.filter(b => b.type === type);
        typeBirds.sort((a, b) => b.fitness - a.fitness);
        
        const perType = BIRD_COUNT / 3;
        const eliteCount = Math.max(1, Math.floor(perType * BIRD_ELITE_RATE));
        
        for (let i = 0; i < eliteCount && i < typeBirds.length; i++) {
          newBirds.push(new Bird(type, typeBirds[i].brain.copy()));
        }
        
        const poolSize = Math.max(eliteCount, Math.floor(perType * BIRD_PARENT_POOL));
        while (newBirds.filter(b => b.type === type).length < perType) {
          const parent = typeBirds[Math.floor(Math.random() * Math.min(typeBirds.length, poolSize))];
          if (parent) {
            const childBrain = parent.brain.copy();
            childBrain.mutate(BIRD_MUT_RATE, BIRD_MUT_POWER);
            newBirds.push(new Bird(type, childBrain));
          } else {
            newBirds.push(new Bird(type)); // Creates new brain
          }
        }
      }
      
      birds = newBirds;
      birds.forEach(b => b.reset());
    }
    
    function evolvePredators() {
      predators.sort((a, b) => b.fitness - a.fitness);
      const newPreds = [];
      
      if (PRED_COUNT === 0) {
        predators = [];
        buildPredatorNests(0);
        return;
      }

      const eliteCount = Math.max(1, Math.floor(PRED_COUNT * PRED_ELITE_RATE));
      for (let i = 0; i < eliteCount && i < predators.length; i++) {
        const newPred = new Predator(predators[i].brain.copy());
        if (PRED_EVOLVE) newPred.huntBonus = predators[i].huntBonus * 0.8;
        newPreds.push(newPred);
      }
      
      const poolSize = Math.max(eliteCount, Math.floor(PRED_COUNT * PRED_PARENT_POOL));
      while (newPreds.length < PRED_COUNT) {
        const parent = predators[Math.floor(Math.random() * Math.min(predators.length, poolSize))];
        if (parent) {
          const childBrain = parent.brain.copy();
          childBrain.mutate(PRED_MUT_RATE, PRED_MUT_POWER);
          const newPred = new Predator(childBrain);
          if (PRED_EVOLVE) newPred.huntBonus = parent.huntBonus * 0.6;
          newPreds.push(newPred);
        } else {
          newPreds.push(new Predator());
        }
      }
      
      predators = newPreds;
      predators.forEach(p => p.reset());
    }
    
    function nextGeneration() {
      generation++;
      evolveBirds();
      evolvePredators();
      survivalTime = 0;
      foodParticles = [];
      deadThisGen = 0;
      
      // Reset the nest for the next generation
      birdNest = new BirdNest(NEST_X, NEST_Y);
      twigPile = [];
      const pileX = TWIG_PILE_X;
      const pileY = TWIG_PILE_Y;
      for (let i = 0; i < TWIG_PILE_COUNT; i++) {
        const heightFactor = Math.random();
        const twigY = pileY - heightFactor * TWIG_PILE_HEIGHT;
        twigPile.push(new Twig(pileX + (Math.random() - 0.5) * TWIG_PILE_WIDTH * (0.7 + 0.3 * heightFactor), twigY));
      }
      twigsInNest = 0;

      seedInitialFood();
    }
    
    function updateHUD() {
      document.getElementById('genValue').textContent = generation;
      document.getElementById('timeValue').textContent = Math.floor(survivalTime / 60) + 's';
      document.getElementById('birdsAlive').textContent = birds.filter(b => b.alive).length;
      document.getElementById('deadThisGen').textContent = deadThisGen;
      document.getElementById('predsCharging').textContent = predators.filter(p => p.inNest).length;
      
      const scouts = birds.filter(b => b.type === 'SCOUT' && b.alive).length;
      const thinkers = birds.filter(b => b.type === 'THINKER' && b.alive).length;
      const flockers = birds.filter(b => b.type === 'FLOCKER' && b.alive).length;
      const perType = BIRD_COUNT / 3;
      
      document.getElementById('scoutCount').textContent = scouts;
      document.getElementById('thinkerCount').textContent = thinkers;
      document.getElementById('flockerCount').textContent = flockers;
      
      document.getElementById('scoutBar').style.width = (scouts / perType * 100) + '%';
      document.getElementById('thinkerBar').style.width = (thinkers / perType * 100) + '%';
      document.getElementById('flockerBar').style.width = (flockers / perType * 100) + '%';
      
      document.getElementById('totalEaten').textContent = totalEaten;
      document.getElementById('birdsHiding').textContent = birds.filter(b => b.hiding).length;
      document.getElementById('foodActive').textContent = foodParticles.filter(f => !f.eaten).length;

      // NEW: HUD for twigs
      document.getElementById('twigsInNest').textContent = twigsInNest;
      document.getElementById('twigBar').style.width = (twigsInNest / TWIG_PILE_COUNT * 100) + '%';

      document.getElementById('recordBestFitness').textContent = Math.round(recordBestFitness);
      document.getElementById('recordLongestLife').textContent = (recordLongestLife / 60).toFixed(1) + 's';
      document.getElementById('recordLargestNest').textContent = recordLargestNest;
      document.getElementById('recordMostKills').textContent = recordMostKills;
    }
    
    function step() {
      globalTime++;
      survivalTime++;
      
      spawnFood();
      
      foodParticles = foodParticles.filter(f => !f.eaten);
      foodParticles.forEach(f => f.update());
      
      birds.forEach(b => {
        b.think();
        b.update();
      });
      
      predators.forEach(p => p.update());
      
      particles = particles.filter(p => {
        p.update();
        return p.life > 0;
      });
      
      alarmWaves = alarmWaves.filter(w => {
        w.update();
        return w.life > 0;
      });
      
      hideSpots.forEach(h => {
        h.occupants = h.occupants.filter(b => b.hiding);
      });
      
      const anyAlive = birds.some(b => b.alive);
      if (!anyAlive && globalTime > 100) { // Small delay
        nextGeneration();
      }
    }
    
    function draw() {
      ctx.fillStyle = '#87CEEB';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      ctx.fillStyle = 'rgba(255,255,255,0.7)';
      for (let i = 0; i < 4; i++) {
        const x = 200 + i * 400;
        const y = 80 + Math.sin(globalTime * 0.01 + i) * 20;
        ctx.beginPath();
        ctx.arc(x, y, 40, 0, Math.PI * 2);
        ctx.arc(x + 30, y - 10, 50, 0, Math.PI * 2);
        ctx.arc(x + 60, y, 45, 0, Math.PI * 2);
        ctx.fill();
      }
      
      ctx.fillStyle = '#8B7355';
      ctx.fillRect(0, GROUND_Y, canvas.width, 50);
      
      ctx.fillStyle = '#6B8E23';
      grassBlades.forEach(blade => {
        ctx.fillRect(blade.x, GROUND_Y - blade.height, blade.width, blade.height);
      });
      
      // UPPDATERAD Rit-ordning
      hideSpots.forEach(h => h.draw());
      predNests.forEach(n => n.draw());
      
      if (birdNest) birdNest.draw(); // NYTT
      trees.forEach(t => t.draw()); // NYTT
      
      // Draw twigs that are not carried
      twigPile.forEach(t => t.draw()); // NYTT
      
      alarmWaves.forEach(w => w.draw());
      foodParticles.forEach(f => f.draw());
      particles.forEach(p => p.draw());
      birds.forEach(b => b.draw());
      
      // Draw BOTH flying and charging predators
      predators.forEach(p => p.draw()); 
      
      updateHUD();
    }
    
    function gameLoop() {
      if (!paused) {
        for (let i = 0; i < timeScale; i++) {
          step();
        }
      }
      draw();
      requestAnimationFrame(gameLoop);
    }
    
    function resetSimulation() {
      generation = 1;
      globalTime = 0;
      survivalTime = 0;
      totalEaten = 0;
      deadThisGen = 0;
      paused = false;
      particles = [];
      foodParticles = [];
      alarmWaves = [];
      trees = []; // NYTT
      twigPile = []; // NYTT
      birdNest = null; // NYTT
      grassBlades = [];
      
      initEnvironment();
      initBirds();
      initPredators();
    }
    
    resetSimulation();
    gameLoop();
  </script>
</body>
</html>
