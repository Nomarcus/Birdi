<!DOCTYPE html>
<html lang="sv">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Birdi ‚Äì Enkla flocken</title>
  <style>
    :root {
      color-scheme: dark;
      --bg-top: #101627;
      --bg-bottom: #070a11;
      --panel: rgba(18, 26, 44, 0.85);
      --panel-border: rgba(108, 126, 255, 0.3);
      --ink: #f3f6ff;
      --muted: #8d95bb;
      --accent: #7f8cff;
      --accent-strong: #4d5ce6;
      --danger: #ff6f91;
      --ok: #7ce0a7;
    }

    *, *::before, *::after {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      font-family: "Inter", system-ui, -apple-system, Segoe UI, sans-serif;
      color: var(--ink);
      background: radial-gradient(circle at 20% 20%, rgba(68, 96, 222, 0.25), transparent 55%),
        radial-gradient(circle at 80% 10%, rgba(255, 110, 158, 0.22), transparent 50%),
        linear-gradient(180deg, var(--bg-top), var(--bg-bottom));
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 24px;
      padding: 32px 20px 48px;
    }

    h1 {
      margin: 0;
      font-size: clamp(1.8rem, 3vw, 2.3rem);
      font-weight: 800;
      letter-spacing: 0.04em;
      text-align: center;
      text-shadow: 0 18px 40px rgba(103, 121, 255, 0.35);
    }

    .toolbar {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: center;
      gap: 16px;
      padding: 20px 24px;
      background: var(--panel);
      border: 1px solid var(--panel-border);
      border-radius: 22px;
      box-shadow: 0 26px 60px rgba(8, 10, 24, 0.55);
      backdrop-filter: blur(18px);
    }

    .btn {
      appearance: none;
      border: none;
      border-radius: 14px;
      font-weight: 700;
      font-size: 0.95rem;
      padding: 12px 22px;
      cursor: pointer;
      color: #05080f;
      background: linear-gradient(135deg, #7ce0a7, #51c98a);
      box-shadow: 0 16px 40px rgba(81, 201, 138, 0.35);
      transition: transform 0.2s ease, box-shadow 0.2s ease;
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }

    .btn.secondary {
      background: linear-gradient(135deg, #8d98ff, #5f6fff);
      box-shadow: 0 16px 40px rgba(127, 140, 255, 0.35);
      color: #f6f7ff;
    }

    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 20px 44px rgba(95, 210, 160, 0.38);
    }

    .btn.secondary:hover {
      box-shadow: 0 20px 44px rgba(127, 140, 255, 0.4);
    }

    .speed-control {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 18px;
      background: rgba(18, 24, 40, 0.9);
      border-radius: 16px;
      border: 1px solid rgba(125, 141, 255, 0.32);
    }

    .speed-control label {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: var(--muted);
      font-weight: 700;
    }

    input[type="range"] {
      accent-color: var(--accent);
      cursor: pointer;
    }

    .speed-value {
      min-width: 40px;
      text-align: right;
      font-weight: 700;
      color: var(--accent);
    }

    canvas {
      width: min(100%, 1100px);
      height: auto;
      border-radius: 22px;
      border: 4px solid rgba(101, 112, 214, 0.4);
      box-shadow: 0 40px 90px rgba(8, 12, 32, 0.65);
      background: linear-gradient(180deg, #9cd8ff, #6f9ee6 40%, #5a86d1 60%, #1d356b 100%);
    }

    .toggle {
      display: inline-flex;
      align-items: center;
      gap: 10px;
      padding: 12px 16px;
      background: rgba(18, 24, 40, 0.8);
      border-radius: 16px;
      border: 1px solid rgba(125, 141, 255, 0.28);
      font-weight: 600;
      letter-spacing: 0.02em;
    }

    .toggle input[type="checkbox"] {
      width: 20px;
      height: 20px;
      accent-color: var(--accent);
      cursor: pointer;
    }

    .stats {
      width: min(1100px, 96vw);
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 14px;
    }

    .stat {
      padding: 16px 18px;
      background: var(--panel);
      border-radius: 18px;
      border: 1px solid var(--panel-border);
      display: flex;
      flex-direction: column;
      gap: 6px;
      box-shadow: 0 20px 48px rgba(7, 9, 24, 0.55);
      backdrop-filter: blur(18px);
    }

    .stat .label {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: var(--muted);
      font-weight: 700;
    }

    .stat .value {
      font-size: 1.8rem;
      font-weight: 800;
      letter-spacing: 0.04em;
    }

    footer {
      text-align: center;
      color: var(--muted);
      font-size: 0.85rem;
      max-width: 640px;
      line-height: 1.5;
    }
  </style>
</head>
<body>
  <h1>üê¶ Birdi ‚Äì En flock, en fiende</h1>

  <div class="toolbar">
    <button class="btn" id="btnReset">üîÑ Ny omg√•ng</button>
    <button class="btn secondary" id="btnPause">‚è∏Ô∏è Pausa</button>
    <div class="speed-control">
      <label for="speedSlider">Hastighet</label>
      <input type="range" id="speedSlider" min="0.25" max="4" step="0.25" value="1">
      <span class="speed-value" id="speedDisplay">1√ó</span>
    </div>
    <label class="toggle">
      <input type="checkbox" id="chkEnergyDeath">
      <span>D√∂d vid energibrist</span>
    </label>
  </div>

  <canvas id="canvas" width="1100" height="680"></canvas>

  <div class="stats">
    <div class="stat">
      <span class="label">Generation</span>
      <span class="value" id="statGeneration">1</span>
    </div>
    <div class="stat">
      <span class="label">F√•glar kvar</span>
      <span class="value" id="statBirds">0</span>
    </div>
    <div class="stat">
      <span class="label">Fiender</span>
      <span class="value" id="statEnemies">0</span>
    </div>
    <div class="stat">
      <span class="label">√ñverlevnad</span>
      <span class="value" id="statTime">0.0 s</span>
    </div>
    <div class="stat">
      <span class="label">Fitness</span>
      <span class="value" id="statFitness">0</span>
    </div>
    <div class="stat">
      <span class="label">B√§sta tiden</span>
      <span class="value" id="statBest">0.0 s</span>
    </div>
  </div>

  <footer>
    En strippad version av Birdi ‚Äì bara en sorts f√•glar som h√•ller ihop och en sorts fiender som jagar. Se hur l√§nge flocken
    kan h√•lla sig vid liv innan n√§sta generation tar vid.
  </footer>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const dpr = window.devicePixelRatio || 1;
    const baseWidth = canvas.width;
    const baseHeight = canvas.height;

    canvas.width = baseWidth * dpr;
    canvas.height = baseHeight * dpr;
    ctx.scale(dpr, dpr);

    const config = {
      birdCount: 28,
      enemyCount: 3,
      birdSpeed: 150,
      enemySpeed: 180,
      separationRadius: 42,
      cohesionRadius: 160,
      alignmentRadius: 120,
      separationStrength: 280,
      cohesionStrength: 28,
      alignmentStrength: 42,
      enemySenseRadius: 220,
      enemyAvoidStrength: 340,
      wanderStrength: 22,
      boundaryStrength: 260,
      enemyTurnSpeed: 320,
      captureRadius: 16,
      padding: 60,
      maxEnergy: 100,
      energyDrainPerSecond: 6,
      energyRechargePerSecond: 18,
      energyLowThreshold: 0.45,
      energyNestAttraction: 220,
      energyDeathPenalty: 120,
      survivalFitnessRate: 2.4,
      wallSensorRange: 160,
      wallSensorStrength: 220,
      nestRadius: 90
    };

    const state = {
      birds: [],
      enemies: [],
      generation: 1,
      survivalTime: 0,
      bestTime: 0,
      paused: false,
      speed: 1,
      resetting: false,
      dieOnEnergyLoss: false,
      fitness: 0
    };

    const elements = {
      birds: document.getElementById('statBirds'),
      enemies: document.getElementById('statEnemies'),
      generation: document.getElementById('statGeneration'),
      time: document.getElementById('statTime'),
      best: document.getElementById('statBest'),
      pause: document.getElementById('btnPause'),
      speedSlider: document.getElementById('speedSlider'),
      speedDisplay: document.getElementById('speedDisplay'),
      energyDeathToggle: document.getElementById('chkEnergyDeath'),
      fitness: document.getElementById('statFitness')
    };

    const nest = {
      x: baseWidth * 0.5,
      y: baseHeight * 0.82,
      radius: config.nestRadius
    };

    state.dieOnEnergyLoss = elements.energyDeathToggle.checked;

    class Bird {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        const angle = Math.random() * Math.PI * 2;
        const speed = config.birdSpeed * 0.4;
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
        this.alive = true;
        this.wanderTimer = Math.random() * Math.PI * 2;
        this.energy = config.maxEnergy;
        this.sensors = {
          wallLeft: 0,
          wallRight: 0,
          wallTop: 0,
          wallBottom: 0,
          enemyDistance: 1,
          enemyDirectionX: 0,
          enemyDirectionY: 0,
          nestDirectionX: 0,
          nestDirectionY: 0,
          nestDistance: 0,
          energyRatio: 1
        };
      }

      update(delta, birds, enemies, simState) {
        if (!this.alive) return { energyDeath: false };

        let ax = 0;
        let ay = 0;

        const { padding } = config;
        const range = config.wallSensorRange;
        const leftDistance = this.x - padding;
        const rightDistance = baseWidth - padding - this.x;
        const topDistance = this.y - padding;
        const bottomDistance = baseHeight - padding - this.y;
        const leftSensor = leftDistance < range ? 1 - leftDistance / range : 0;
        const rightSensor = rightDistance < range ? 1 - rightDistance / range : 0;
        const topSensor = topDistance < range ? 1 - topDistance / range : 0;
        const bottomSensor = bottomDistance < range ? 1 - bottomDistance / range : 0;

        if (leftSensor > 0) ax += config.wallSensorStrength * leftSensor;
        if (rightSensor > 0) ax -= config.wallSensorStrength * rightSensor;
        if (topSensor > 0) ay += config.wallSensorStrength * topSensor;
        if (bottomSensor > 0) ay -= config.wallSensorStrength * bottomSensor;

        // Separation & cohesion
        let separationCount = 0;
        let cohesionCount = 0;
        let alignmentCount = 0;
        let cohesionX = 0;
        let cohesionY = 0;
        let alignmentX = 0;
        let alignmentY = 0;

        for (const other of birds) {
          if (other === this || !other.alive) continue;
          const dx = other.x - this.x;
          const dy = other.y - this.y;
          const dist = Math.hypot(dx, dy);
          if (dist < 1) continue;

          if (dist < config.separationRadius) {
            const weight = 1 - dist / config.separationRadius;
            ax -= (dx / dist) * config.separationStrength * weight;
            ay -= (dy / dist) * config.separationStrength * weight;
            separationCount++;
          }

          if (dist < config.cohesionRadius) {
            cohesionX += other.x;
            cohesionY += other.y;
            cohesionCount++;
          }

          if (dist < config.alignmentRadius) {
            alignmentX += other.vx;
            alignmentY += other.vy;
            alignmentCount++;
          }
        }

        if (cohesionCount > 0) {
          const cx = cohesionX / cohesionCount;
          const cy = cohesionY / cohesionCount;
          const dx = cx - this.x;
          const dy = cy - this.y;
          const dist = Math.hypot(dx, dy);
          if (dist > 1) {
            ax += (dx / dist) * config.cohesionStrength;
            ay += (dy / dist) * config.cohesionStrength;
          }
        }

        if (alignmentCount > 0) {
          const avx = alignmentX / alignmentCount;
          const avy = alignmentY / alignmentCount;
          const dist = Math.hypot(avx, avy);
          if (dist > 1) {
            ax += (avx / dist) * config.alignmentStrength;
            ay += (avy / dist) * config.alignmentStrength;
          }
        }

        // Avoid enemies
        let nearestEnemy = null;
        let nearestDist = Infinity;
        for (const enemy of enemies) {
          const dx = enemy.x - this.x;
          const dy = enemy.y - this.y;
          const dist = Math.hypot(dx, dy);
          if (dist < nearestDist) {
            nearestDist = dist;
            nearestEnemy = enemy;
          }
        }

        if (nearestEnemy && nearestDist < config.enemySenseRadius) {
          const dx = this.x - nearestEnemy.x;
          const dy = this.y - nearestEnemy.y;
          const dist = Math.max(1, nearestDist);
          const weight = 1 - Math.min(1, dist / config.enemySenseRadius);
          ax += (dx / dist) * config.enemyAvoidStrength * weight;
          ay += (dy / dist) * config.enemyAvoidStrength * weight;
        }

        // Keep inside the world
        if (this.x < padding) ax += config.boundaryStrength;
        else if (this.x > baseWidth - padding) ax -= config.boundaryStrength;
        if (this.y < padding) ay += config.boundaryStrength;
        else if (this.y > baseHeight - padding) ay -= config.boundaryStrength;

        // Gentle wander to avoid stagnation
        this.wanderTimer += delta * 2;
        ax += Math.cos(this.wanderTimer) * config.wanderStrength;
        ay += Math.sin(this.wanderTimer) * config.wanderStrength;

        const nestDx = nest.x - this.x;
        const nestDy = nest.y - this.y;
        const nestDist = Math.hypot(nestDx, nestDy);
        const nestDirX = nestDist > 0 ? nestDx / nestDist : 0;
        const nestDirY = nestDist > 0 ? nestDy / nestDist : 0;

        this.energy = Math.max(0, this.energy - config.energyDrainPerSecond * delta);
        if (nestDist < nest.radius) {
          this.energy = Math.min(
            config.maxEnergy,
            this.energy + config.energyRechargePerSecond * delta
          );
        }

        const energyRatio = this.energy / config.maxEnergy;
        if (energyRatio < config.energyLowThreshold) {
          const urgency = (config.energyLowThreshold - energyRatio) / config.energyLowThreshold;
          ax += nestDirX * config.energyNestAttraction * urgency;
          ay += nestDirY * config.energyNestAttraction * urgency;
        }

        this.sensors = {
          wallLeft: leftSensor,
          wallRight: rightSensor,
          wallTop: topSensor,
          wallBottom: bottomSensor,
          enemyDistance: nearestDist === Infinity ? 1 : Math.min(1, nearestDist / config.enemySenseRadius),
          enemyDirectionX: nearestEnemy ? (nearestEnemy.x - this.x) / Math.max(1, nearestDist) : 0,
          enemyDirectionY: nearestEnemy ? (nearestEnemy.y - this.y) / Math.max(1, nearestDist) : 0,
          nestDirectionX: nestDirX,
          nestDirectionY: nestDirY,
          nestDistance: Math.min(1, nestDist / Math.hypot(baseWidth, baseHeight)),
          energyRatio
        };

        if (simState?.dieOnEnergyLoss && this.energy <= 0) {
          this.alive = false;
          return { energyDeath: true };
        }

        this.vx += ax * delta;
        this.vy += ay * delta;

        const speed = Math.hypot(this.vx, this.vy);
        const maxSpeed = config.birdSpeed;
        if (speed > maxSpeed) {
          const scale = maxSpeed / speed;
          this.vx *= scale;
          this.vy *= scale;
        }

        this.x += this.vx * delta;
        this.y += this.vy * delta;
        this.x = Math.max(padding, Math.min(baseWidth - padding, this.x));
        this.y = Math.max(padding, Math.min(baseHeight - padding, this.y));
        return { energyDeath: false };
      }

      draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        const angle = Math.atan2(this.vy, this.vx);
        ctx.rotate(angle);
        ctx.fillStyle = '#ffe27a';
        ctx.strokeStyle = '#c9973e';
        ctx.lineWidth = 2;

        ctx.beginPath();
        ctx.moveTo(14, 0);
        ctx.quadraticCurveTo(-4, 8, -12, 0);
        ctx.quadraticCurveTo(-4, -8, 14, 0);
        ctx.fill();
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(-4, -2);
        ctx.lineTo(-12, -16);
        ctx.moveTo(-4, 2);
        ctx.lineTo(-12, 16);
        ctx.stroke();

        ctx.fillStyle = 'rgba(4, 6, 14, 0.6)';
        ctx.fillRect(-12, 14, 24, 5);
        const ratio = Math.max(0, Math.min(1, this.energy / config.maxEnergy));
        ctx.fillStyle = ratio > 0.5 ? '#7ce0a7' : ratio > 0.25 ? '#ffe27a' : '#ff6f91';
        ctx.fillRect(-12, 14, 24 * ratio, 5);

        ctx.restore();
      }
    }

    class Enemy {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        const angle = Math.random() * Math.PI * 2;
        this.vx = Math.cos(angle) * config.enemySpeed * 0.3;
        this.vy = Math.sin(angle) * config.enemySpeed * 0.3;
        this.target = null;
      }

      update(delta, birds) {
        // acquire target
        if (!this.target || !this.target.alive) {
          let closest = null;
          let bestDist = Infinity;
          for (const bird of birds) {
            if (!bird.alive) continue;
            const dx = bird.x - this.x;
            const dy = bird.y - this.y;
            const dist = Math.hypot(dx, dy);
            if (dist < bestDist) {
              bestDist = dist;
              closest = bird;
            }
          }
          this.target = closest;
        }

        let ax = 0;
        let ay = 0;

        if (this.target) {
          const dx = this.target.x - this.x;
          const dy = this.target.y - this.y;
          const dist = Math.hypot(dx, dy);
          if (dist > 1) {
            ax += (dx / dist) * config.enemyTurnSpeed;
            ay += (dy / dist) * config.enemyTurnSpeed;
          }

          if (dist < config.captureRadius && this.target.alive) {
            this.target.alive = false;
            this.target = null;
          }
        } else {
          ax += (Math.random() - 0.5) * config.enemyTurnSpeed * 0.2;
          ay += (Math.random() - 0.5) * config.enemyTurnSpeed * 0.2;
        }

        const { padding } = config;
        if (this.x < padding) ax += config.boundaryStrength * 0.6;
        else if (this.x > baseWidth - padding) ax -= config.boundaryStrength * 0.6;
        if (this.y < padding) ay += config.boundaryStrength * 0.6;
        else if (this.y > baseHeight - padding) ay -= config.boundaryStrength * 0.6;

        this.vx += ax * delta;
        this.vy += ay * delta;

        const speed = Math.hypot(this.vx, this.vy);
        const maxSpeed = config.enemySpeed;
        if (speed > maxSpeed) {
          const scale = maxSpeed / speed;
          this.vx *= scale;
          this.vy *= scale;
        }

        this.x += this.vx * delta;
        this.y += this.vy * delta;
        this.x = Math.max(padding, Math.min(baseWidth - padding, this.x));
        this.y = Math.max(padding, Math.min(baseHeight - padding, this.y));
      }

      draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        const angle = Math.atan2(this.vy, this.vx);
        ctx.rotate(angle);
        ctx.fillStyle = '#ff6f91';
        ctx.strokeStyle = '#d64f6f';
        ctx.lineWidth = 2;

        ctx.beginPath();
        ctx.moveTo(18, 0);
        ctx.lineTo(-14, 10);
        ctx.lineTo(-6, 0);
        ctx.lineTo(-14, -10);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        ctx.restore();
      }
    }

    function spawnBird() {
      const padding = config.padding;
      const x = padding + Math.random() * (baseWidth - padding * 2);
      const y = padding + Math.random() * (baseHeight - padding * 2);
      return new Bird(x, y);
    }

    function spawnEnemy() {
      const padding = config.padding;
      const x = padding + Math.random() * (baseWidth - padding * 2);
      const y = padding + Math.random() * (baseHeight - padding * 2);
      return new Enemy(x, y);
    }

    function resetSimulation() {
      state.birds = Array.from({ length: config.birdCount }, spawnBird);
      state.enemies = Array.from({ length: config.enemyCount }, spawnEnemy);
      state.survivalTime = 0;
      state.fitness = 0;
      state.resetting = false;
      state.paused = false;
      elements.pause.textContent = '‚è∏Ô∏è Pausa';
      updateStats();
    }

    function updateStats() {
      const aliveBirds = state.birds.filter(b => b.alive).length;
      elements.birds.textContent = aliveBirds;
      elements.enemies.textContent = state.enemies.length;
      elements.generation.textContent = state.generation;
      elements.time.textContent = `${state.survivalTime.toFixed(1)} s`;
      elements.best.textContent = `${state.bestTime.toFixed(1)} s`;
      elements.fitness.textContent = Math.round(state.fitness);
    }

    let lastTime = performance.now();

    function loop(now) {
      requestAnimationFrame(loop);
      const rawDelta = Math.min(0.05, (now - lastTime) / 1000);
      lastTime = now;
      if (state.paused) {
        drawScene();
        return;
      }

      const delta = rawDelta * state.speed;
      const hadLivingBird = state.birds.some(bird => bird.alive);
      let energyDeaths = 0;
      for (const bird of state.birds) {
        const result = bird.update(delta, state.birds, state.enemies, state);
        if (result?.energyDeath) {
          energyDeaths += 1;
        }
      }

      for (const enemy of state.enemies) {
        enemy.update(delta, state.birds);
      }

      if (hadLivingBird) {
        state.survivalTime += delta;
      }

      const aliveBirds = state.birds.filter(bird => bird.alive);
      const aliveCount = aliveBirds.length;
      if (aliveCount > 0) {
        state.fitness += aliveCount * delta * config.survivalFitnessRate;
      }
      if (energyDeaths > 0) {
        state.fitness -= energyDeaths * config.energyDeathPenalty;
      }

      if (aliveCount === 0 && !state.resetting) {
        state.resetting = true;
        state.bestTime = Math.max(state.bestTime, state.survivalTime);
        updateStats();
        setTimeout(() => {
          state.generation += 1;
          resetSimulation();
        }, 800);
      }

      updateStats();
      drawScene();
    }

    function drawScene() {
      ctx.clearRect(0, 0, baseWidth, baseHeight);

      // Ground
      const gradient = ctx.createLinearGradient(0, baseHeight * 0.55, 0, baseHeight);
      gradient.addColorStop(0, '#3d6bc2');
      gradient.addColorStop(1, '#183264');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, baseHeight * 0.55, baseWidth, baseHeight * 0.45);

      // subtle horizon line
      ctx.strokeStyle = 'rgba(255,255,255,0.15)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, baseHeight * 0.55);
      ctx.lineTo(baseWidth, baseHeight * 0.55);
      ctx.stroke();

      // nest indicator
      ctx.save();
      ctx.translate(nest.x, nest.y);
      const nestGradient = ctx.createRadialGradient(0, 0, nest.radius * 0.2, 0, 0, nest.radius);
      nestGradient.addColorStop(0, 'rgba(255, 226, 122, 0.55)');
      nestGradient.addColorStop(1, 'rgba(120, 78, 26, 0.08)');
      ctx.fillStyle = nestGradient;
      ctx.beginPath();
      ctx.arc(0, 0, nest.radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = 'rgba(245, 194, 114, 0.6)';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.arc(0, 0, nest.radius * 0.6, 0, Math.PI * 2);
      ctx.stroke();
      ctx.restore();

      // soft sun
      const sunGradient = ctx.createRadialGradient(baseWidth * 0.75, baseHeight * 0.28, 0, baseWidth * 0.75, baseHeight * 0.28, 110);
      sunGradient.addColorStop(0, 'rgba(255,255,255,0.7)');
      sunGradient.addColorStop(1, 'rgba(255,255,255,0)');
      ctx.fillStyle = sunGradient;
      ctx.beginPath();
      ctx.arc(baseWidth * 0.75, baseHeight * 0.28, 110, 0, Math.PI * 2);
      ctx.fill();

      // draw birds & enemies
      for (const bird of state.birds) {
        if (bird.alive) {
          bird.draw(ctx);
        } else {
          ctx.save();
          ctx.globalAlpha = 0.25;
          ctx.fillStyle = '#d9e0ff';
          ctx.beginPath();
          ctx.arc(bird.x, bird.y, 6, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }
      }

      for (const enemy of state.enemies) {
        enemy.draw(ctx);
      }
    }

    document.getElementById('btnReset').addEventListener('click', () => {
      state.generation = 1;
      state.bestTime = 0;
      resetSimulation();
    });

    elements.pause.addEventListener('click', () => {
      state.paused = !state.paused;
      elements.pause.textContent = state.paused ? '‚ñ∂Ô∏è Forts√§tt' : '‚è∏Ô∏è Pausa';
    });

    elements.speedSlider.addEventListener('input', event => {
      const value = Number(event.target.value);
      state.speed = value;
      const text = value
        .toFixed(2)
        .replace(/\.00$/, '')
        .replace(/(\.\d)0$/, '$1');
      elements.speedDisplay.textContent = `${text}√ó`;
    });

    elements.energyDeathToggle.addEventListener('change', event => {
      state.dieOnEnergyLoss = event.target.checked;
    });

    window.addEventListener('resize', () => {
      const rect = canvas.getBoundingClientRect();
      canvas.style.height = `${rect.width * (baseHeight / baseWidth)}px`;
    });

    elements.speedSlider.dispatchEvent(new Event('input'));
    resetSimulation();
    updateStats();
    requestAnimationFrame(loop);
  </script>
</body>
</html>
