<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ü¶Ö NEAT: Evolution Through Hunting (Balanced Build)</title>
  <style>
    :root { --sky1:#87CEEB; --sky2:#E0F6FF; --panel:#ffffffee; --ink:#23303f; --ok:#28a745; --accent:#0d6efd; --danger:#dc3545; }
    *{box-sizing:border-box; margin:0; padding:0;}
    body{ font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      display:flex; flex-direction:column; align-items:center; color:var(--ink); padding:20px; min-height:100vh; }
    h1{ color:#fff; margin:8px 0 16px; text-shadow:0 3px 10px rgba(0,0,0,0.3); font-weight:900; font-size:28px; }
    #canvas{ border:4px solid #2d3748; background:#87CEEB url('assets/sky-background.png') center/cover no-repeat;
      box-shadow:0 20px 60px rgba(0,0,0,.4); border-radius:16px; max-width:100%; }
    .controls{ margin:20px 0; padding:24px; backdrop-filter: blur(16px);
      background:var(--panel); border-radius:20px; box-shadow:0 15px 40px rgba(0,0,0,.2); 
      width:min(1700px,96vw); border:2px solid rgba(255,255,255,0.3); }
    .top-bar{ display:flex; justify-content:space-between; align-items:center; flex-wrap:wrap; gap:16px; margin-bottom:20px; }
    .btn-group{ display:flex; gap:12px; flex-wrap:wrap; }
    .btn{ padding:14px 24px; border:0; border-radius:12px; background:var(--ok); color:#fff;
      font-weight:800; cursor:pointer; box-shadow:0 6px 20px rgba(40,167,69,.3);
      transition:all .2s ease; font-size:15px; display:inline-flex; align-items:center;
      justify-content:center; gap:8px; text-decoration:none; }
    .btn.secondary{ background:var(--accent); box-shadow:0 6px 20px rgba(13,110,253,.3); }
    .btn.danger{ background:var(--danger); box-shadow:0 6px 20px rgba(220,53,69,.3); }
    .btn:hover{ transform:translateY(-2px); filter:brightness(1.1); }
    .speed-control{ display:flex; align-items:center; gap:12px; padding:10px 18px; border-radius:12px;
      background:rgba(255,255,255,0.7); border:2px solid rgba(255,255,255,0.6);
      box-shadow:0 6px 18px rgba(0,0,0,0.12); backdrop-filter:blur(12px); }
    .speed-control label{ font-weight:800; font-size:13px; letter-spacing:0.5px; text-transform:uppercase;
      color:#334155; }
    .speed-control input[type="range"]{ width:180px; accent-color:var(--danger); height:6px;
      background:linear-gradient(90deg, rgba(220,53,69,0.15), rgba(220,53,69,0.4));
      border-radius:999px; cursor:pointer; }
    .speed-value{ font-weight:900; font-size:18px; color:var(--danger); min-width:48px; text-align:right; }
    .score-panel{ display:flex; gap:24px; align-items:center; flex-wrap:wrap; }
    .score-item{ text-align:center; padding:12px 20px; background:rgba(255,255,255,0.5); 
      border-radius:12px; border:2px solid rgba(0,0,0,0.1); }
    .score-label{ font-size:12px; font-weight:700; color:#555; text-transform:uppercase; letter-spacing:0.5px; }
    .score-value{ font-size:28px; font-weight:900; margin-top:4px; }
    .score-value.ok{ color:#28a745; }
    .score-value.danger{ color:#dc3545; }
    .section{ margin:20px 0; }
    .section-title{ font-size:16px; font-weight:900; color:#2d3748; margin-bottom:12px; 
      text-transform:uppercase; letter-spacing:1px; display:flex; align-items:center; gap:8px; 
      border-bottom:3px solid #667eea; padding-bottom:8px; cursor:pointer; user-select:none; }
    .section-title:hover{ opacity:0.8; }
    .section-title::before{ content:'‚ñº '; font-size:12px; }
    .section-title.collapsed::before{ content:'‚ñ∂ '; }
    .collapse-content{ max-height:2000px; overflow:hidden; transition:max-height 0.3s ease; }
    .collapse-content.hidden{ max-height:0; }
    .grid{ display:grid; grid-template-columns:repeat(auto-fit,minmax(300px,1fr)); gap:12px; }
    .control{ display:flex; align-items:center; justify-content:space-between; gap:12px; 
      padding:12px 14px; background:rgba(255,255,255,0.7); border-radius:10px; 
      border:2px solid rgba(0,0,0,0.05); transition:all .2s ease; }
    .control:hover{ background:rgba(255,255,255,0.9); border-color:var(--accent); }
    .control label{ font-weight:700; font-size:13px; color:#2d3748; flex:1; }
    .control input[type="range"]{ width:140px; accent-color:var(--accent); cursor:pointer; }
    .control input[type="number"]{ width:80px; padding:6px; border-radius:6px; border:2px solid #ccc; font-weight:700; }
    .control input[type="checkbox"]{ width:auto; height:20px; cursor:pointer; }
    .chip{ padding:6px 12px; background:#e6f2ff; border:2px solid #b3d9ff; border-radius:999px; 
      font-weight:800; color:#0066cc; min-width:60px; text-align:center; font-size:13px; }
    .chip.danger{ background:#ffe6e6; border-color:#ffb3b3; color:#cc0000; }
    .chip.ok{ background:#e6ffe6; border-color:#b3ffb3; color:#00cc00; }
    .chip.warn{ background:#fff4e6; border-color:#ffd699; color:#cc6600; }
    .stats-grid{ display:grid; grid-template-columns:repeat(auto-fit,minmax(140px,1fr)); gap:14px; margin-top:16px; }
    .stat-card{ padding:16px; background:linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
      border-radius:14px; text-align:center; box-shadow:0 8px 24px rgba(0,0,0,.2); 
      border:2px solid rgba(255,255,255,0.2); color:#fff; }
    .stat-label{ font-size:11px; font-weight:700; text-transform:uppercase; letter-spacing:0.5px; opacity:0.9; }
    .stat-value{ font-size:28px; font-weight:900; margin-top:6px; text-shadow:0 2px 4px rgba(0,0,0,0.2); }
    .bar{ height:6px; background:rgba(255,255,255,0.3); border-radius:999px; overflow:hidden; margin-top:8px; }
    .bar > div{ height:100%; width:0%; transition:width .3s ease; background:#fff; box-shadow:0 0 8px rgba(255,255,255,0.5); }
    .legend{ display:flex; gap:20px; flex-wrap:wrap; justify-content:center; padding:16px; 
      background:rgba(255,255,255,0.4); border-radius:12px; margin-top:16px; }
    .legend-item{ display:flex; align-items:center; gap:8px; font-weight:700; font-size:13px; }
    .legend-dot{ width:16px; height:16px; border-radius:50%; border:3px solid #333; box-shadow:0 2px 8px rgba(0,0,0,0.3); }
    /* NEW for legend */
    .legend-line{ width:16px; height:8px; border-radius:4px; border:3px solid #333; box-shadow:0 2px 8px rgba(0,0,0,0.3); }
    .legend-rect{ width:16px; height:16px; border-radius:4px; border:3px solid #333; box-shadow:0 2px 8px rgba(0,0,0,0.3); }

    .tip{ padding:12px 16px; background:#fff3cd; border:2px solid #ffc107; border-radius:10px; 
      margin-top:12px; font-size:13px; font-weight:600; color:#856404; }
    .tip.info{ background:#d1ecf1; border-color:#17a2b8; color:#0c5460; }
    .tip.danger{ background:#f8d7da; border-color:#f5c6cb; color:#721c24; }
  </style>
</head>
<body>
  <h1>ü¶Ö NEAT EVOLUTION: Build the Nest & Survive üå≥</h1>
  <canvas id="canvas" width="1800" height="900"></canvas>

  <div class="controls">
    <div class="top-bar">
      <div class="btn-group">
        <button class="btn" id="btnReset">üîÑ New Simulation</button>
        <button class="btn secondary" id="btnPause">‚è∏Ô∏è Pause</button>
        <a class="btn secondary" href="neat-guide.html">üìò NEAT Guide</a>
      </div>
      <div class="speed-control">
        <label for="speedSlider">Speed</label>
        <input type="range" id="speedSlider" min="1" max="50" value="1">
        <span class="speed-value" id="speedDisplay">1√ó</span>
      </div>
      <div class="score-panel">
        <div class="score-item">
          <div class="score-label">Generation</div>
          <div class="score-value ok" id="genValue">1</div>
        </div>
        <div class="score-item">
          <div class="score-label">Survival Time</div>
          <div class="score-value" id="timeValue">0s</div>
        </div>
        <div class="score-item">
          <div class="score-label">üê¶ Birds Alive</div>
          <div class="score-value ok" id="birdsAlive">0</div>
        </div>
        <div class="score-item">
          <div class="score-label">üíÄ Deaths this Gen</div>
          <div class="score-value danger" id="deadThisGen">0</div>
        </div>
        <div class="score-item">
          <div class="score-label">‚öîÔ∏è Fiendevinster</div>
          <div class="score-value danger" id="enemyWins">0</div>
        </div>
      </div>
    </div>

    <div class="legend">
      <div class="legend-item"><div class="legend-dot" style="background:#FFD700;"></div>Scout (Fast)</div>
      <div class="legend-item"><div class="legend-dot" style="background:#4CAF50;"></div>Thinker (Clever)</div>
      <div class="legend-item"><div class="legend-dot" style="background:#2196F3;"></div>Flocker (Social)</div>
      <div class="legend-item"><div class="legend-dot" style="background:#9C27B0;"></div>Predator (Immortal)</div>
      <div class="legend-item"><div class="legend-dot" style="background:#3ECF5B;"></div>Hide Spot</div>
      <div class="legend-item"><div class="legend-rect" style="background:#006400;"></div>Tree (Obstacle)</div>
      <div class="legend-item"><div class="legend-line" style="background:#D2691E;"></div>Twig</div>
      <div class="legend-item"><div class="legend-dot" style="background:#A0522D;"></div>Bird Nest</div>
    </div>

    <div class="tip info">
      üå≤ <strong>NEW GOAL:</strong> The birds must now build a nest! Collect twigs from the pile in the middle of the
      arena and carry them to the nest in the upper left. Every twig grants a <strong>big fitness bonus!</strong>
      Trees are obstacles that everyone must fly around or above.
    </div>

    <div class="tip danger">
      ‚ö†Ô∏è <strong>HIDE SPOTS:</strong> Birds can hide for a <strong>maximum of 3 seconds</strong> (180 frames),
      then they MUST leave for a <strong>5 second cooldown</strong>.
    </div>

    <div class="tip info">
      ü¶Ö <strong>PREDATOR NESTS:</strong> Predators may only charge for about <strong>4 seconds</strong> before being
      forced back into the hunt and must stay away for roughly <strong>3.5 seconds</strong> (adjustable below) before they
      can recharge again.
    </div>

    <div class="section">
      <div class="section-title collapsible" data-target="basic">‚öôÔ∏è Core Settings</div>
      <div id="basic" class="collapse-content">
        <div class="grid">
          <div class="control">
            <label>üê¶ Total Small Birds</label>
            <input type="number" id="birdCount" value="30" min="9" max="500">
          </div>
          <div class="control">
            <label>ü¶Ö Predator Count</label>
            <input type="range" id="predCount" min="0" max="500" value="0">
            <span class="chip danger" id="uiPredCount">0</span>
          </div>
          <div class="control">
            <label>üçé Food Spawn Rate</label>
            <input type="range" id="foodRate" min="1" max="20" value="8">
            <span class="chip" id="uiFoodRate">8</span>
          </div>
          <div class="control">
            <label>üå≥ Hide Spots Count</label>
            <input type="range" id="hideSpots" min="3" max="15" value="6">
            <span class="chip ok" id="uiHideSpots">6</span>
          </div>
          <div class="control">
            <label>üè† Capacity per Hide Spot</label>
            <input type="range" id="hideCapacity" min="1" max="8" value="3">
            <span class="chip" id="uiHideCapacity">3</span>
          </div>
          <div class="control">
            <label>üå≤ Trees (obstacles)</label>
            <input type="range" id="treeCount" min="0" max="15" value="0">
            <span class="chip warn" id="uiTreeCount">0</span>
          </div>
        </div>
      </div>
    </div>
    
    <div class="section">
      <div class="section-title collapsible" data-target="nest-build">üè† Nest Building (New Objective!)</div>
      <div id="nest-build" class="collapse-content">
        <div class="grid">
          <div class="control">
            <label>ü™µ Twigs in the Pile</label>
            <input type="range" id="twigCount" min="10" max="200" value="50" step="10">
            <span class="chip" id="uiTwigCount">50</span>
          </div>
          <div class="control">
            <label>üèÜ Fitness Bonus per Twig</label>
            <input type="range" id="twigBonus" min="500" max="10000" value="3000" step="100">
            <span class="chip ok" id="uiTwigBonus">3000</span>
          </div>
        </div>
      </div>
    </div>

    <div class="section">
      <div class="section-title collapsible collapsed" data-target="layout-controls">üß≠ Layout Controls</div>
      <div id="layout-controls" class="collapse-content hidden">
        <div class="grid">
          <div class="control">
            <label>ü™µ Twig Pile X</label>
            <input type="range" id="twigPosX" min="50" max="1750" value="900">
            <span class="chip" id="uiTwigPosX">900</span>
          </div>
          <div class="control">
            <label>ü™µ Twig Pile Y</label>
            <input type="range" id="twigPosY" min="200" max="850" value="840">
            <span class="chip" id="uiTwigPosY">840</span>
          </div>
          <div class="control">
            <label>üéÆ Playfield Offset X</label>
            <input type="range" id="boardOffsetX" min="-400" max="400" value="0">
            <span class="chip" id="uiBoardOffsetX">0</span>
          </div>
          <div class="control">
            <label>üéÆ Playfield Offset Y</label>
            <input type="range" id="boardOffsetY" min="-200" max="200" value="0">
            <span class="chip" id="uiBoardOffsetY">0</span>
          </div>
        </div>
      </div>
    </div>

    <div class="section">
      <div class="section-title collapsible collapsed" data-target="hide-settings">üå≥ Hide Spot Settings (Critical for Evolution!)</div>
      <div id="hide-settings" class="collapse-content hidden">
        <div class="grid">
          <div class="control">
            <label>‚è±Ô∏è Max Hide Time (frames)</label>
            <input type="range" id="maxHideTime" min="20" max="300" value="180">
            <span class="chip warn" id="uiMaxHideTime">180 (~3s)</span>
          </div>
          <div class="control">
            <label>‚è≥ Cooldown after Hiding (frames)</label>
            <input type="range" id="hideCooldown" min="60" max="1200" value="300">
            <span class="chip warn" id="uiHideCooldown">300 (~5s)</span>
          </div>
          <div class="control">
            <label>üò∞ Fitness Penalty while Hiding</label>
            <input type="range" id="hidePenalty" min="0" max="20" value="2">
            <span class="chip warn" id="uiHidePenalty">-2</span>
          </div>
        </div>
      </div>
    </div>

    <div class="section">
      <div class="section-title collapsible collapsed" data-target="bird-evo">üß¨ Small Bird Evolution</div>
      <div id="bird-evo" class="collapse-content hidden">
        <div class="grid">
          <div class="control">
            <label>Elite % (top survivors kept)</label>
            <input type="range" id="birdElite" min="5" max="100" value="20">
            <span class="chip ok" id="uiBirdElite">20%</span>
          </div>
          <div class="control">
            <label>Parent Pool % (eligible to breed)</label>
            <input type="range" id="birdParent" min="20" max="80" value="50">
            <span class="chip ok" id="uiBirdParent">50%</span>
          </div>
          <div class="control">
            <label>Mutation Rate %</label>
            <input type="range" id="birdMutRate" min="5" max="50" value="15">
            <span class="chip ok" id="uiBirdMutRate">15%</span>
          </div>
          <div class="control">
            <label>Mutation Power</label>
            <input type="range" id="birdMutPower" min="10" max="80" value="35">
            <span class="chip ok" id="uiBirdMutPower">0.35</span>
          </div>
          <div class="control">
            <label>üß† Hidden Neurons</label>
            <input type="range" id="birdHidden" min="8" max="48" value="24">
            <span class="chip ok" id="uiBirdHidden">24</span>
          </div>
        </div>
      </div>
    </div>

    <div class="section">
      <div class="section-title collapsible collapsed" data-target="pred-evo">ü¶Ö Predator Evolution</div>
      <div id="pred-evo" class="collapse-content hidden">
        <div class="grid">
          <div class="control">
            <label>Elite %</label>
            <input type="range" id="predElite" min="10" max="100" value="30">
            <span class="chip danger" id="uiPredElite">30%</span>
          </div>
          <div class="control">
            <label>Parent Pool %</label>
            <input type="range" id="predParent" min="30" max="90" value="60">
            <span class="chip danger" id="uiPredParent">60%</span>
          </div>
          <div class="control">
            <label>Mutation Rate %</label>
            <input type="range" id="predMutRate" min="5" max="50" value="20">
            <span class="chip danger" id="uiPredMutRate">20%</span>
          </div>
          <div class="control">
            <label>Mutation Power</label>
            <input type="range" id="predMutPower" min="10" max="80" value="30">
            <span class="chip danger" id="uiPredMutPower">0.30</span>
          </div>
          <div class="control">
            <label>üß† Hidden Neurons</label>
            <input type="range" id="predHidden" min="8" max="40" value="20">
            <span class="chip danger" id="uiPredHidden">20</span>
          </div>
        </div>
      </div>
    </div>

    <div class="section">
      <div class="section-title collapsible collapsed" data-target="balance">‚öñÔ∏è Balance & Behaviour</div>
      <div id="balance" class="collapse-content hidden">
        <div class="grid">
          <div class="control">
            <label>üí® Stamina Cost</label>
            <input type="range" id="staminaCost" min="1" max="15" value="2">
            <span class="chip" id="uiStaminaCost">2</span>
          </div>
          <div class="control">
            <label>üîã Energy per Movement</label>
            <input type="range" id="energyCost" min="1" max="20" value="3">
            <span class="chip" id="uiEnergyCost">0.03</span>
          </div>
          <div class="control">
            <label>üö® Warning Boost %</label>
            <input type="range" id="warnBoost" min="0" max="100" value="30">
            <span class="chip" id="uiWarnBoost">30%</span>
          </div>
          <div class="control">
            <label>üö® Alarm Radius</label>
            <input type="range" id="alarmRange" min="50" max="400" value="150">
            <span class="chip" id="uiAlarmRange">150</span>
          </div>
          <div class="control">
            <label>üçé Food Energy Value</label>
            <input type="range" id="foodValue" min="20" max="100" value="60">
            <span class="chip" id="uiFoodValue">60</span>
          </div>
        </div>
      </div>
    </div>

    <div class="section">
      <div class="section-title collapsible collapsed" data-target="pred-settings">ü¶Ö Predator Settings</div>
      <div id="pred-settings" class="collapse-content hidden">
        <div class="grid">
          <div class="control">
            <label>‚ö° Hunt Speed</label>
            <input type="range" id="predSpeed" min="4" max="14" value="7">
            <span class="chip danger" id="uiPredSpeed">7</span>
          </div>
          <div class="control">
            <label>üîã Nest Charge Speed</label>
            <input type="range" id="nestCharge" min="1" max="15" value="5">
            <span class="chip danger" id="uiNestCharge">5</span>
          </div>
          <div class="control">
            <label>‚è≥ Nest Cooldown</label>
            <input type="range" id="predNestCooldown" min="60" max="600" step="30" value="210">
            <span class="chip danger" id="uiPredNestCooldown">210 (~3.5s)</span>
          </div>
          <div class="control">
            <label>üçñ Energy per Capture</label>
            <input type="range" id="killEnergy" min="20" max="100" value="40">
            <span class="chip danger" id="uiKillEnergy">40</span>
          </div>
          <div class="control">
            <label>üí™ Fitness per Capture</label>
            <input type="range" id="killFitness" min="500" max="5000" step="100" value="3000">
            <span class="chip danger" id="uiKillFitness">3000</span>
          </div>
          <div class="control">
            <label>üìà Progressive Evolution</label>
            <input type="checkbox" id="predEvolve" checked>
          </div>
          <div class="control">
            <label>üéØ Pack Hunting</label>
            <input type="checkbox" id="packHunt" checked>
          </div>
        </div>
      </div>
    </div>

    <div class="section">
      <div class="section-title collapsible" data-target="sensor">üõ∞Ô∏è Sensors &amp; Rewards</div>
      <div id="sensor" class="collapse-content hidden">
        <div class="grid">
          <div class="control">
            <label>üì° Ray Range</label>
            <input type="range" id="rayRange" min="120" max="400" value="220">
            <span class="chip" id="uiRayRange">220</span>
          </div>
          <div class="control">
            <label>üõ°Ô∏è Bird Avoid Gain</label>
            <input type="range" id="avoidGainBird" min="0.5" max="2" step="0.05" value="1.2">
            <span class="chip" id="uiAvoidGainBird">1.20</span>
          </div>
          <div class="control">
            <label>ü¶Ö Predator Avoid Gain</label>
            <input type="range" id="avoidGainPred" min="0.5" max="2" step="0.05" value="1.2">
            <span class="chip" id="uiAvoidGainPred">1.20</span>
          </div>
          <div class="control">
            <label>üéöÔ∏è Output Mix</label>
            <input type="range" id="mixOutput" min="0.3" max="1" step="0.05" value="0.8">
            <span class="chip" id="uiMixOutput">0.80</span>
          </div>
          <div class="control">
            <label>üõ°Ô∏è Safe Ray Threshold</label>
            <input type="range" id="safePred" min="0.2" max="0.8" step="0.05" value="0.35">
            <span class="chip" id="uiSafePred">0.35</span>
          </div>
          <div class="control">
            <label>‚è±Ô∏è Idle Frames</label>
            <input type="range" id="idleFrames" min="30" max="120" value="45">
            <span class="chip" id="uiIdleFrames">45</span>
          </div>
        </div>
        <div class="grid">
          <div class="control">
            <label>üèÜ k_p1 (Pred Progress)</label>
            <input type="range" id="kp1" min="0" max="0.005" step="0.0001" value="0.0015">
            <span class="chip" id="uiKp1">0.0015</span>
          </div>
          <div class="control">
            <label>üéØ k_p2 (Flank/Ambush)</label>
            <input type="range" id="kp2" min="0" max="0.2" step="0.005" value="0.05">
            <span class="chip" id="uiKp2">0.050</span>
          </div>
          <div class="control">
            <label>üê¶ k_b1 (Progress)</label>
            <input type="range" id="kb1" min="0" max="0.005" step="0.0001" value="0.0015">
            <span class="chip" id="uiKb1">0.0015</span>
          </div>
          <div class="control">
            <label>ü™µ k_b2 (Delivery Bonus)</label>
            <input type="range" id="kb2" min="0" max="1" step="0.01" value="0.2">
            <span class="chip" id="uiKb2">0.20</span>
          </div>
          <div class="control">
            <label>üß± k_b3 (Wall Safety)</label>
            <input type="range" id="kb3" min="0" max="1" step="0.01" value="0.45">
            <span class="chip" id="uiKb3">0.45</span>
          </div>
          <div class="control">
            <label>üé≤ k_b4 (Idle Penalty)</label>
            <input type="range" id="kb4" min="0" max="0.2" step="0.005" value="0.02">
            <span class="chip" id="uiKb4">0.02</span>
          </div>
        </div>
      </div>
    </div>

    <div class="section">
      <div class="section-title">üìä Live Statistics</div>
      <div class="stats-grid">
        <div class="stat-card">
          <div class="stat-label">‚ö° Scout</div>
          <div class="stat-value" id="scoutCount">0</div>
          <div class="bar"><div id="scoutBar"></div></div>
        </div>
        <div class="stat-card">
          <div class="stat-label">üß† Thinker</div>
          <div class="stat-value" id="thinkerCount">0</div>
          <div class="bar"><div id="thinkerBar"></div></div>
        </div>
        <div class="stat-card">
          <div class="stat-label">ü§ù Flocker</div>
          <div class="stat-value" id="flockerCount">0</div>
          <div class="bar"><div id="flockerBar"></div></div>
        </div>
        <div class="stat-card">
          <div class="stat-label">ü™µ Twigs in Nest</div>
          <div class="stat-value" id="twigsInNest">0</div>
          <div class="bar"><div id="twigBar"></div></div>
        </div>
        <div class="stat-card">
          <div class="stat-label">üíÄ Total Dead</div>
          <div class="stat-value" id="totalEaten">0</div>
        </div>
        <div class="stat-card">
          <div class="stat-label">üè† Predators Charging</div>
          <div class="stat-value" id="predsCharging">0</div>
        </div>
        <div class="stat-card">
          <div class="stat-label">üå≥ In Hide Spots</div>
          <div class="stat-value" id="birdsHiding">0</div>
        </div>
        <div class="stat-card">
          <div class="stat-label">üçé Mat ute</div>
          <div class="stat-value" id="foodActive">0</div>
        </div>
      </div>
    </div>

    <div class="section">
      <div class="section-title">üèÜ Records</div>
      <div class="stats-grid">
        <div class="stat-card">
          <div class="stat-label">‚≠ê Highest Fitness</div>
          <div class="stat-value" id="recordBestFitness">0</div>
        </div>
        <div class="stat-card">
          <div class="stat-label">‚è±Ô∏è Longest Life (s)</div>
          <div class="stat-value" id="recordLongestLife">0s</div>
        </div>
        <div class="stat-card">
          <div class="stat-label">ü™π Largest Nest</div>
          <div class="stat-value" id="recordLargestNest">0</div>
        </div>
        <div class="stat-card">
          <div class="stat-label">üíÄ Most Birds Caught</div>
          <div class="stat-value" id="recordMostKills">0</div>
        </div>
      </div>
    </div>

    <div class="section">
      <div class="section-title">üß≠ Behavior Telemetry</div>
      <div class="stats-grid">
        <div class="stat-card">
          <div class="stat-label">üöß Bird Wall Hits</div>
          <div class="stat-value" id="birdWallCrashes">0</div>
        </div>
        <div class="stat-card">
          <div class="stat-label">ü™® Predator Wall Hits</div>
          <div class="stat-value" id="predWallCrashes">0</div>
        </div>
        <div class="stat-card">
          <div class="stat-label">üìè Avg Wall Distance</div>
          <div class="stat-value" id="avgWallDist">0</div>
        </div>
        <div class="stat-card">
          <div class="stat-label">ü™µ Twig Deliveries</div>
          <div class="stat-value" id="twigDeliveriesStat">0</div>
        </div>
        <div class="stat-card">
          <div class="stat-label">üé≤ Idle Breaks</div>
          <div class="stat-value" id="idleBreaksStat">0</div>
        </div>
      </div>
      <div class="stats-grid">
        <div class="stat-card">
          <div class="stat-label">üê¶ EVADE</div>
          <div class="stat-value" id="birdStateEvade">0s</div>
        </div>
        <div class="stat-card">
          <div class="stat-label">üê¶ Collect Twig</div>
          <div class="stat-value" id="birdStateTwig">0s</div>
        </div>
        <div class="stat-card">
          <div class="stat-label">üê¶ Forage</div>
          <div class="stat-value" id="birdStateForage">0s</div>
        </div>
        <div class="stat-card">
          <div class="stat-label">üê¶ Return Home</div>
          <div class="stat-value" id="birdStateReturn">0s</div>
        </div>
        <div class="stat-card">
          <div class="stat-label">ü¶Ö Search</div>
          <div class="stat-value" id="predStateSearch">0s</div>
        </div>
        <div class="stat-card">
          <div class="stat-label">ü¶Ö Chase</div>
          <div class="stat-value" id="predStateChase">0s</div>
        </div>
        <div class="stat-card">
          <div class="stat-label">ü¶Ö Flank</div>
          <div class="stat-value" id="predStateFlank">0s</div>
        </div>
        <div class="stat-card">
          <div class="stat-label">ü¶Ö Ambush</div>
          <div class="stat-value" id="predStateAmbush">0s</div>
        </div>
        <div class="stat-card">
          <div class="stat-label">ü¶Ö Retreat</div>
          <div class="stat-value" id="predStateRetreat">0s</div>
        </div>
        <div class="stat-card">
          <div class="stat-label">ü¶Ö Nest</div>
          <div class="stat-value" id="predStateNest">0s</div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Prevent duplicate custom element definition errors from third-party scripts.
    if (window.customElements && !window.__customElementDeduper) {
      const originalDefine = window.customElements.define.bind(window.customElements);
      window.customElements.define = function(name, constructor, options) {
        if (!window.customElements.get(name)) {
          originalDefine(name, constructor, options);
        }
      };
      window.__customElementDeduper = true;
    }

    const clamp = (value, min = 0, max = 1) => Math.max(min, Math.min(max, value));
    const applyCollisionPenalty = (current, penalty, floor) => {
      const reduced = current - penalty;
      if (reduced <= 0 && current > floor) {
        return floor;
      }
      return Math.max(0, reduced);
    };

    // Config
    let BIRD_COUNT = 30;
    let PRED_COUNT = 0;
    let FOOD_SPAWN_RATE = 8;
    let HIDE_SPOT_COUNT = 6;
    let HIDE_CAPACITY = 3;
    let TREE_COUNT = 0; // NEW
    
    // NEW: Nest building
    let TWIG_PILE_COUNT = 50;
    let TWIG_FITNESS_BONUS = 3000;
    const TWIG_PICKUP_RATIO = 0.12;
    const TWIG_PROGRESS_FACTOR = 0.6;
    const TWIG_BACKTRACK_FACTOR = 0.3;
    const TWIG_IDLE_PENALTY = 2;
    const TWIG_IDLE_INTERVAL = 45;
    const TWIG_DEATH_RATIO = 0.3;

    const MATING_DISTANCE = 20;
    const MATING_REQUIRED_FRAMES = 180; // 3 seconds at 60fps
    const MATING_COOLDOWN_FRAMES = 360;
    const MATING_FITNESS_BONUS = 3500;

    const ENEMY_WIN_FITNESS = 8000;
    const ENEMY_WIN_ENERGY_BONUS = 60;

    let RAY_RANGE = 220; // @added
    const RAY_ANGLES = [0, Math.PI / 4, -Math.PI / 4, Math.PI / 2, -Math.PI / 2, Math.PI]; // @added
    let AVOID_GAIN_F = 1.2; // @added
    let AVOID_GAIN_P = 1.2; // @added
    let MIX_OUTPUT = 0.8; // @added
    let SAFE_PRED_N = 0.35; // @added
    let IDLE_FRAME_LIMIT = 45; // @added

    let k_p1 = 0.0015, k_p2 = 0.05, k_b1 = 0.0015, k_b2 = 0.2, k_b3 = 0.45, k_b4 = 0.02; // @added

    const GROUND_PENALTY_ENERGY = 20;
    const GROUND_PENALTY_STAMINA = 12;
    const GROUND_PENALTY_BASE = 420;
    const WALL_PENALTY_ENERGY = 12;
    const WALL_PENALTY_BASE = 220;
    const CEILING_PENALTY_ENERGY = 14;
    const CEILING_PENALTY_BASE = 260;

    const PRED_WALL_CRASH_ENERGY_RATIO = 0.12;
    const PRED_WALL_CRASH_FITNESS = 140;
    const PRED_WALL_FORCED_RETURN = 260;
    const PRED_CORNER_WARN_DIST = 140;
    const PRED_CORNER_ENERGY_DRAIN = 0.9;
    const PRED_CORNER_FITNESS_DRAIN = 2.6;
    const PRED_CHASE_PROGRESS_REWARD = 0.9;
    const PRED_CHASE_PROGRESS_PENALTY = 0.45;
    const PRED_CHASE_PROXIMITY_BONUS = 1.6;
    const PRED_HIGH_SPEED_REWARD = 0.6;
    const PRED_NEST_MAX_TIME = 240; // ~4s vila i boet
    let PRED_NEST_COOLDOWN = 210; // ~3.5s innan √•terkomst
    const PRED_BASE_ENERGY = 110;
    const PRED_MAX_ENERGY = 160;
    const PRED_ACTIVE_ENERGY_DRAIN = 0.35;
    const PRED_FORCED_EXIT_MIN_RATIO = 0.5;
    const PRED_KILL_ENERGY_MULTIPLIER = 1.2;
    const COLLISION_ENERGY_FLOOR = 5;
    const COLLISION_STAMINA_FLOOR = 5;
    
    // CRITICAL for evolution!
    let MAX_HIDE_TIME = 180; // Max 3 seconds in a hide spot (longer time to rest)
    let HIDE_COOLDOWN = 300; // 5 second cooldown (faster recovery)
    let HIDE_PENALTY = 2; // Smaller penalty for hiding
    
    // Bird evolution
    let BIRD_ELITE_RATE = 0.20;
    let BIRD_PARENT_POOL = 0.50;
    let BIRD_MUT_RATE = 0.15;
    let BIRD_MUT_POWER = 0.35;
    let BIRD_HIDDEN = 24;
    
    // Pred evolution
    let PRED_ELITE_RATE = 0.30;
    let PRED_PARENT_POOL = 0.60;
    let PRED_MUT_RATE = 0.20;
    let PRED_MUT_POWER = 0.30;
    let PRED_HIDDEN = 20;
    
    // Balance
    let STAMINA_COST = 2; // Less fatigue
    let ENERGY_MOVE_COST = 0.03; // Base energy cost per step
    let WARN_BOOST = 0.30;
    let ALARM_RANGE = 150;
    let FOOD_VALUE = 60; // More energy from food
    
    // Pred settings
    let PRED_SPEED = 7;
    let NEST_CHARGE_RATE = 5;
    let KILL_ENERGY = 40; // Less energy from catches (balanced with shorter bar)
    let KILL_FITNESS = 3000;
    let PRED_EVOLVE = true;
    let PACK_HUNT = true;
    
    let generation = 1;
    let globalTime = 0;
    let survivalTime = 0;
    let paused = false;
    let timeScale = 1;
    let totalEaten = 0;
    let deadThisGen = 0;
    let twigsInNest = 0; // NYTT
    
    let birds = [];
    let birdIdCounter = 0;
    let predators = [];
    let foodParticles = [];
    let hideSpots = [];
    let predNests = [];
    let particles = [];
    let alarmWaves = [];
    let trees = []; // NYTT
    let twigPile = []; // NYTT
    let birdNest = null; // NYTT
    let grassBlades = [];

    let recordBestFitness = 0;
    let recordLongestLife = 0;
    let recordLargestNest = 0;
    let recordMostKills = 0;

    let enemyWinCount = 0;
    let enemyWinAwarded = false;

    const matingTimers = new Map();

    const telemetry = { // @added
      birdWallCrashes: 0, // @added
      predWallCrashes: 0, // @added
      twigDeliveries: 0, // @added
      birdStateTime: { EVADE: 0, COLLECT_TWIG: 0, FORAGE: 0, RETURN_HOME: 0 }, // @added
      predStateTime: { SEARCH: 0, CHASE: 0, FLANK: 0, AMBUSH: 0, RETREAT: 0, NEST: 0 }, // @added
      idleBreaks: 0, // @added
      avgWallDist: 0 // @added
    }; // @added

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const GROUND_Y = canvas.height - 50;
    const NEST_X = 140;
    const NEST_Y = GROUND_Y - 140;
    let TWIG_PILE_X = canvas.width / 2;
    let TWIG_PILE_Y = GROUND_Y - 10;

    function sampleRay(x, y, a, maxD = RAY_RANGE, step = 6) { // @added
      const dx = Math.cos(a), dy = Math.sin(a); // @added
      for (let d = 6; d <= maxD; d += step) { // @added
        const rx = x + dx * d, ry = y + dy * d; // @added
        if (rx <= 0 || ry <= 0 || rx >= canvas.width || ry >= GROUND_Y) return d / maxD; // @added
        for (const t of (trees || [])) if (rx > t.x && rx < t.x + t.width && ry > t.y) return d / maxD; // @added
      } // @added
      return 1; // @added
    }

    function nearestBird(x, y) { // @added
      let best = null, bestDist = Infinity; // @added
      for (const b of birds) { // @added
        if (!b.alive || b.hiding) continue; // @added
        const d = Math.hypot(x - b.x, y - b.y); // @added
        if (d < bestDist) { bestDist = d; best = b; } // @added
      } // @added
      return { target: best, dist: bestDist }; // @added
    }

    function nearestPredator(x, y) { // @added
      let best = null, bestDist = Infinity; // @added
      for (const p of predators) { // @added
        if (!p.alive || p.inNest) continue; // @added
        const d = Math.hypot(x - p.x, y - p.y); // @added
        if (d < bestDist) { bestDist = d; best = p; } // @added
      } // @added
      return { target: best, dist: bestDist }; // @added
    }

    function nearestTwig(x, y) { // @added
      let best = null, bestDist = Infinity; // @added
      for (const t of twigPile) { // @added
        if (t.carriedBy) continue; // @added
        const d = Math.hypot(x - t.x, y - t.y); // @added
        if (d < bestDist) { bestDist = d; best = t; } // @added
      } // @added
      return { target: best, dist: bestDist }; // @added
    }
    const TWIG_PILE_WIDTH = 220;
    const TWIG_PILE_HEIGHT = 120;
    let PLAYFIELD_OFFSET_X = 0;
    let PLAYFIELD_OFFSET_Y = 0;
    const INITIAL_FOOD_COUNT = 25;

    const backgroundImage = new Image();
    backgroundImage.src = 'assets/sky-background.png';
    let backgroundReady = false;
    backgroundImage.onload = () => { backgroundReady = true; };

    const birdhouseSprite = new Image();
    birdhouseSprite.src = 'assets/birdhouse.svg';
    let birdhouseReady = false;
    birdhouseSprite.onload = () => { birdhouseReady = true; };
    
    const BIRD_TYPES = {
      SCOUT: { color: '#FFD700', speed: 1.4, vision: 1.3, stamina: 0.8, name: 'Scout' },
      THINKER: { color: '#4CAF50', speed: 0.9, vision: 1.6, stamina: 1.2, name: 'Thinker' },
      FLOCKER: { color: '#2196F3', speed: 1.1, vision: 1.1, stamina: 1.0, name: 'Flocker' }
    };

    const BIRD_TYPE_KEYS = Object.keys(BIRD_TYPES);
    const getBirdTypeAllocations = total => {
      const typeCount = BIRD_TYPE_KEYS.length;
      const base = Math.floor(total / typeCount);
      let remainder = total % typeCount;
      return BIRD_TYPE_KEYS.reduce((acc, type) => {
        const extra = remainder > 0 ? 1 : 0;
        acc[type] = base + extra;
        if (remainder > 0) remainder--;
        return acc;
      }, {});
    };
    
    // Collapsible sections
    document.querySelectorAll('.collapsible').forEach(el => {
      el.addEventListener('click', () => {
        const target = document.getElementById(el.dataset.target);
        el.classList.toggle('collapsed');
        target.classList.toggle('hidden');
      });
    });
    
    // Event listeners
    const speedSlider = document.getElementById('speedSlider');
    const speedDisplay = document.getElementById('speedDisplay');
    const applySpeed = value => {
      const newScale = Math.max(1, Math.min(50, parseInt(value, 10) || 1));
      timeScale = newScale;
      speedDisplay.textContent = `${newScale}√ó`;
    };

    applySpeed(speedSlider.value);

    document.getElementById('btnReset').addEventListener('click', () => resetSimulation());
    document.getElementById('btnPause').addEventListener('click', () => { paused = !paused; });
    speedSlider.addEventListener('input', e => applySpeed(e.target.value));
    
    // Basic settings
    document.getElementById('birdCount').addEventListener('change', e => {
      const v = parseInt(e.target.value);
      BIRD_COUNT = Math.max(9, Math.min(500, isNaN(v) ? BIRD_COUNT : v));
      e.target.value = BIRD_COUNT;
    });
    
    const syncPredatorCount = () => {
      if (PRED_COUNT <= 0) {
        predators = [];
        buildPredatorNests(0);
        return;
      }

      if (!predNests.length) {
        buildPredatorNests(PRED_COUNT);
      }

      if (predators.length > PRED_COUNT) {
        predators.length = PRED_COUNT;
      } else {
        while (predators.length < PRED_COUNT) {
          predators.push(new Predator());
        }
      }
    };

    document.getElementById('predCount').addEventListener('input', e => {
      PRED_COUNT = parseInt(e.target.value);
      document.getElementById('uiPredCount').textContent = PRED_COUNT;
      syncPredatorCount();
    });
    
    document.getElementById('foodRate').addEventListener('input', e => {
      FOOD_SPAWN_RATE = parseInt(e.target.value);
      document.getElementById('uiFoodRate').textContent = FOOD_SPAWN_RATE;
    });
    
    document.getElementById('hideSpots').addEventListener('input', e => {
      HIDE_SPOT_COUNT = parseInt(e.target.value);
      document.getElementById('uiHideSpots').textContent = HIDE_SPOT_COUNT;
    });
    
    document.getElementById('hideCapacity').addEventListener('input', e => {
      HIDE_CAPACITY = parseInt(e.target.value);
      document.getElementById('uiHideCapacity').textContent = HIDE_CAPACITY;
      hideSpots.forEach(h => h.capacity = HIDE_CAPACITY);
    });
    
    document.getElementById('treeCount').addEventListener('input', e => { // NYTT
      TREE_COUNT = parseInt(e.target.value);
      document.getElementById('uiTreeCount').textContent = TREE_COUNT;
    });

    // NYTT: Nest settings
    document.getElementById('twigCount').addEventListener('input', e => {
      TWIG_PILE_COUNT = parseInt(e.target.value);
      document.getElementById('uiTwigCount').textContent = TWIG_PILE_COUNT;
      regenerateTwigPile();
    });

    document.getElementById('twigBonus').addEventListener('input', e => {
      TWIG_FITNESS_BONUS = parseInt(e.target.value);
      document.getElementById('uiTwigBonus').textContent = TWIG_FITNESS_BONUS;
    });

    const twigPosXInput = document.getElementById('twigPosX');
    const twigPosYInput = document.getElementById('twigPosY');
    const boardOffsetXInput = document.getElementById('boardOffsetX');
    const boardOffsetYInput = document.getElementById('boardOffsetY');

    const applyBoardOffset = () => {
      canvas.style.transform = `translate(${PLAYFIELD_OFFSET_X}px, ${PLAYFIELD_OFFSET_Y}px)`;
    };

    twigPosXInput.addEventListener('input', e => {
      const value = parseInt(e.target.value, 10);
      if (Number.isNaN(value)) return;
      TWIG_PILE_X = value;
      document.getElementById('uiTwigPosX').textContent = TWIG_PILE_X;
      regenerateTwigPile();
    });

    twigPosYInput.addEventListener('input', e => {
      const value = parseInt(e.target.value, 10);
      if (Number.isNaN(value)) return;
      TWIG_PILE_Y = Math.max(100, Math.min(GROUND_Y - 10, value));
      e.target.value = TWIG_PILE_Y;
      document.getElementById('uiTwigPosY').textContent = TWIG_PILE_Y;
      regenerateTwigPile();
    });

    boardOffsetXInput.addEventListener('input', e => {
      const value = parseInt(e.target.value, 10);
      if (Number.isNaN(value)) return;
      PLAYFIELD_OFFSET_X = value;
      document.getElementById('uiBoardOffsetX').textContent = PLAYFIELD_OFFSET_X;
      applyBoardOffset();
    });

    boardOffsetYInput.addEventListener('input', e => {
      const value = parseInt(e.target.value, 10);
      if (Number.isNaN(value)) return;
      PLAYFIELD_OFFSET_Y = value;
      document.getElementById('uiBoardOffsetY').textContent = PLAYFIELD_OFFSET_Y;
      applyBoardOffset();
    });

    twigPosXInput.value = Math.round(TWIG_PILE_X);
    document.getElementById('uiTwigPosX').textContent = Math.round(TWIG_PILE_X);
    twigPosYInput.value = Math.round(TWIG_PILE_Y);
    document.getElementById('uiTwigPosY').textContent = Math.round(TWIG_PILE_Y);
    boardOffsetXInput.value = PLAYFIELD_OFFSET_X;
    document.getElementById('uiBoardOffsetX').textContent = PLAYFIELD_OFFSET_X;
    boardOffsetYInput.value = PLAYFIELD_OFFSET_Y;
    document.getElementById('uiBoardOffsetY').textContent = PLAYFIELD_OFFSET_Y;
    applyBoardOffset();

    // Hide settings
    document.getElementById('maxHideTime').addEventListener('input', e => {
      MAX_HIDE_TIME = parseInt(e.target.value);
      const seconds = (MAX_HIDE_TIME / 60).toFixed(1);
      document.getElementById('uiMaxHideTime').textContent = `${MAX_HIDE_TIME} (~${seconds}s)`;
    });
    
    document.getElementById('hideCooldown').addEventListener('input', e => {
      HIDE_COOLDOWN = parseInt(e.target.value);
      const seconds = (HIDE_COOLDOWN / 60).toFixed(1);
      document.getElementById('uiHideCooldown').textContent = `${HIDE_COOLDOWN} (~${seconds}s)`;
    });
    
    document.getElementById('hidePenalty').addEventListener('input', e => {
      HIDE_PENALTY = parseInt(e.target.value);
      document.getElementById('uiHidePenalty').textContent = '-' + HIDE_PENALTY;
    });
    
    // Bird evolution
    document.getElementById('birdElite').addEventListener('input', e => {
      BIRD_ELITE_RATE = parseInt(e.target.value) / 100;
      document.getElementById('uiBirdElite').textContent = e.target.value + '%';
    });
    
    document.getElementById('birdParent').addEventListener('input', e => {
      BIRD_PARENT_POOL = parseInt(e.target.value) / 100;
      document.getElementById('uiBirdParent').textContent = e.target.value + '%';
    });
    
    document.getElementById('birdMutRate').addEventListener('input', e => {
      BIRD_MUT_RATE = parseInt(e.target.value) / 100;
      document.getElementById('uiBirdMutRate').textContent = e.target.value + '%';
    });
    
    document.getElementById('birdMutPower').addEventListener('input', e => {
      BIRD_MUT_POWER = parseInt(e.target.value) / 100;
      document.getElementById('uiBirdMutPower').textContent = (parseInt(e.target.value) / 100).toFixed(2);
    });
    
    document.getElementById('birdHidden').addEventListener('input', e => {
      BIRD_HIDDEN = parseInt(e.target.value);
      document.getElementById('uiBirdHidden').textContent = BIRD_HIDDEN;
    });
    
    // Pred evolution
    document.getElementById('predElite').addEventListener('input', e => {
      PRED_ELITE_RATE = parseInt(e.target.value) / 100;
      document.getElementById('uiPredElite').textContent = e.target.value + '%';
    });
    
    document.getElementById('predParent').addEventListener('input', e => {
      PRED_PARENT_POOL = parseInt(e.target.value) / 100;
      document.getElementById('uiPredParent').textContent = e.target.value + '%';
    });
    
    document.getElementById('predMutRate').addEventListener('input', e => {
      PRED_MUT_RATE = parseInt(e.target.value) / 100;
      document.getElementById('uiPredMutRate').textContent = e.target.value + '%';
    });
    
    document.getElementById('predMutPower').addEventListener('input', e => {
      PRED_MUT_POWER = parseInt(e.target.value) / 100;
      document.getElementById('uiPredMutPower').textContent = (parseInt(e.target.value) / 100).toFixed(2);
    });
    
    document.getElementById('predHidden').addEventListener('input', e => {
      PRED_HIDDEN = parseInt(e.target.value);
      document.getElementById('uiPredHidden').textContent = PRED_HIDDEN;
    });
    
    // Balance
    document.getElementById('staminaCost').addEventListener('input', e => {
      STAMINA_COST = parseInt(e.target.value);
      document.getElementById('uiStaminaCost').textContent = STAMINA_COST;
    });

    document.getElementById('energyCost').addEventListener('input', e => {
      const raw = parseInt(e.target.value);
      ENERGY_MOVE_COST = raw / 100;
      document.getElementById('uiEnergyCost').textContent = ENERGY_MOVE_COST.toFixed(2);
    });

    document.getElementById('uiEnergyCost').textContent = ENERGY_MOVE_COST.toFixed(2);

    document.getElementById('warnBoost').addEventListener('input', e => {
      WARN_BOOST = parseInt(e.target.value) / 100;
      document.getElementById('uiWarnBoost').textContent = e.target.value + '%';
    });
    
    document.getElementById('alarmRange').addEventListener('input', e => {
      ALARM_RANGE = parseInt(e.target.value);
      document.getElementById('uiAlarmRange').textContent = ALARM_RANGE;
    });
    
    document.getElementById('foodValue').addEventListener('input', e => {
      FOOD_VALUE = parseInt(e.target.value);
      document.getElementById('uiFoodValue').textContent = FOOD_VALUE;
    });
    
    // Pred settings
    document.getElementById('predSpeed').addEventListener('input', e => {
      PRED_SPEED = parseInt(e.target.value);
      document.getElementById('uiPredSpeed').textContent = PRED_SPEED;
    });
    
    document.getElementById('nestCharge').addEventListener('input', e => {
      NEST_CHARGE_RATE = parseInt(e.target.value);
      document.getElementById('uiNestCharge').textContent = NEST_CHARGE_RATE;
    });

    const predNestCooldownInput = document.getElementById('predNestCooldown');
    const predNestCooldownLabel = document.getElementById('uiPredNestCooldown');
    const formatPredCooldown = frames => {
      const seconds = (frames / 60).toFixed(1);
      return `${frames} (~${seconds}s)`;
    };
    predNestCooldownInput.value = PRED_NEST_COOLDOWN;
    predNestCooldownLabel.textContent = formatPredCooldown(PRED_NEST_COOLDOWN);
    predNestCooldownInput.addEventListener('input', e => {
      PRED_NEST_COOLDOWN = parseInt(e.target.value, 10);
      predNestCooldownLabel.textContent = formatPredCooldown(PRED_NEST_COOLDOWN);
      predators.forEach(pred => {
        if (!pred.inNest) {
          pred.nestCooldown = Math.min(pred.nestCooldown, PRED_NEST_COOLDOWN);
        }
      });
    });
    
    document.getElementById('killEnergy').addEventListener('input', e => {
      KILL_ENERGY = parseInt(e.target.value);
      document.getElementById('uiKillEnergy').textContent = KILL_ENERGY;
    });

    document.getElementById('killFitness').addEventListener('input', e => {
      KILL_FITNESS = parseInt(e.target.value);
      document.getElementById('uiKillFitness').textContent = KILL_FITNESS;
    });

    document.getElementById('rayRange').addEventListener('input', e => { // @added
      RAY_RANGE = parseInt(e.target.value, 10); // @added
      document.getElementById('uiRayRange').textContent = RAY_RANGE; // @added
    });
    document.getElementById('avoidGainBird').addEventListener('input', e => { // @added
      AVOID_GAIN_F = parseFloat(e.target.value); // @added
      document.getElementById('uiAvoidGainBird').textContent = AVOID_GAIN_F.toFixed(2); // @added
    });
    document.getElementById('avoidGainPred').addEventListener('input', e => { // @added
      AVOID_GAIN_P = parseFloat(e.target.value); // @added
      document.getElementById('uiAvoidGainPred').textContent = AVOID_GAIN_P.toFixed(2); // @added
    });
    document.getElementById('mixOutput').addEventListener('input', e => { // @added
      MIX_OUTPUT = parseFloat(e.target.value); // @added
      document.getElementById('uiMixOutput').textContent = MIX_OUTPUT.toFixed(2); // @added
    });
    document.getElementById('safePred').addEventListener('input', e => { // @added
      SAFE_PRED_N = parseFloat(e.target.value); // @added
      document.getElementById('uiSafePred').textContent = SAFE_PRED_N.toFixed(2); // @added
    });
    document.getElementById('idleFrames').addEventListener('input', e => { // @added
      IDLE_FRAME_LIMIT = parseInt(e.target.value, 10); // @added
      document.getElementById('uiIdleFrames').textContent = IDLE_FRAME_LIMIT; // @added
    });
    document.getElementById('kp1').addEventListener('input', e => { // @added
      k_p1 = parseFloat(e.target.value); // @added
      document.getElementById('uiKp1').textContent = k_p1.toFixed(4); // @added
    });
    document.getElementById('kp2').addEventListener('input', e => { // @added
      k_p2 = parseFloat(e.target.value); // @added
      document.getElementById('uiKp2').textContent = k_p2.toFixed(3); // @added
    });
    document.getElementById('kb1').addEventListener('input', e => { // @added
      k_b1 = parseFloat(e.target.value); // @added
      document.getElementById('uiKb1').textContent = k_b1.toFixed(4); // @added
    });
    document.getElementById('kb2').addEventListener('input', e => { // @added
      k_b2 = parseFloat(e.target.value); // @added
      document.getElementById('uiKb2').textContent = k_b2.toFixed(2); // @added
    });
    document.getElementById('kb3').addEventListener('input', e => { // @added
      k_b3 = parseFloat(e.target.value); // @added
      document.getElementById('uiKb3').textContent = k_b3.toFixed(2); // @added
    });
    document.getElementById('kb4').addEventListener('input', e => { // @added
      k_b4 = parseFloat(e.target.value); // @added
      document.getElementById('uiKb4').textContent = k_b4.toFixed(2); // @added
    });
    
    document.getElementById('predEvolve').addEventListener('change', e => {
      PRED_EVOLVE = e.target.checked;
    });
    
    document.getElementById('packHunt').addEventListener('change', e => {
      PACK_HUNT = e.target.checked;
    });
    
    // Classes
    class Particle {
      constructor(x, y, color, vx = 0, vy = 0) {
        this.x = x;
        this.y = y;
        this.vx = vx || (Math.random() - 0.5) * 4;
        this.vy = vy || (Math.random() - 0.5) * 4 - 2;
        this.color = color;
        this.size = 2 + Math.random() * 3;
        this.life = 30;
        this.maxLife = 30;
      }
      update() {
        this.x += this.vx;
        this.y += this.vy;

        this.vy += 0.15;
        this.vx *= 0.98;
        this.life--;
      }
        draw() {
          const alpha = clamp(this.life / this.maxLife);
          ctx.save();
        ctx.globalAlpha = alpha;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
    }
    
    class AlarmWave {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.radius = 0;
        this.maxRadius = ALARM_RANGE;
        this.life = 40;
      }
      update() {
        this.radius += 6;
        this.life--;
      }
      draw() {
        const alpha = clamp(this.life / 40);
        ctx.save();
        ctx.globalAlpha = alpha * 0.3;
        ctx.strokeStyle = '#FF6B6B';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
      }
    }
    
    class FoodParticle {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.eaten = false;
        this.size = 6;
        this.pulse = Math.random() * Math.PI * 2;
      }
      update() {
        this.pulse += 0.1;
      }
      draw() {
        if (this.eaten) return;
        const s = this.size + Math.sin(this.pulse) * 2;
        ctx.fillStyle = '#8BC34A';
        ctx.beginPath();
        ctx.arc(this.x, this.y, s, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#689F38';
        ctx.lineWidth = 2;
        ctx.stroke();
      }
    }
    
    class HideSpot {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.radius = 50;
        this.capacity = HIDE_CAPACITY;
        this.occupants = [];
      }
      canHide() {
        return this.occupants.length < this.capacity;
      }
      addBird(bird) {
        if (this.canHide()) {
          this.occupants.push(bird);
          return true;
        }
        return false;
      }
      removeBird(bird) {
        const idx = this.occupants.indexOf(bird);
        if (idx >= 0) this.occupants.splice(idx, 1);
      }
      draw() {
        const ringWidth = 14;
        const ringRadius = this.radius - ringWidth / 2;

        ctx.save();

        // Glow
        const glowGrad = ctx.createRadialGradient(this.x, this.y, ringRadius * 0.3, this.x, this.y, ringRadius + ringWidth);
        glowGrad.addColorStop(0, 'rgba(142, 211, 123, 0.45)');
        glowGrad.addColorStop(1, 'rgba(142, 211, 123, 0)');
        ctx.fillStyle = glowGrad;
        ctx.beginPath();
        ctx.arc(this.x, this.y, ringRadius + ringWidth, 0, Math.PI * 2);
        ctx.fill();

        // Ring
        const ringGrad = ctx.createLinearGradient(this.x, this.y - ringRadius, this.x, this.y + ringRadius);
        ringGrad.addColorStop(0, '#3ecf5b');
        ringGrad.addColorStop(1, '#1f8f3c');
        ctx.strokeStyle = ringGrad;
        ctx.lineWidth = ringWidth;
        ctx.beginPath();
        ctx.arc(this.x, this.y, ringRadius, 0, Math.PI * 2);
        ctx.stroke();

        // Inner field
        const innerGrad = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, ringRadius * 0.75);
        innerGrad.addColorStop(0, 'rgba(26, 73, 37, 0.75)');
        innerGrad.addColorStop(1, 'rgba(26, 73, 37, 0.35)');
        ctx.fillStyle = innerGrad;
        ctx.beginPath();
        ctx.arc(this.x, this.y, ringRadius * 0.75, 0, Math.PI * 2);
        ctx.fill();

        // Icon
        ctx.fillStyle = '#d5f8d7';
        ctx.font = '28px "Segoe UI Emoji", "Apple Color Emoji", sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('üõ°Ô∏è', this.x, this.y - 6);

        // Capacity text
        ctx.fillStyle = 'rgba(255, 255, 255, 0.85)';
        ctx.font = 'bold 16px "Segoe UI", sans-serif';
        ctx.fillText(`${this.occupants.length}/${this.capacity}`, this.x, this.y + 20);

        ctx.restore();
      }
    }
    
    class PredatorNest {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.radius = 60;
      }
      draw() {
        ctx.fillStyle = '#3C2F2F';
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.strokeStyle = '#1C1C1C';
        ctx.lineWidth = 4;
        ctx.stroke();
        
        ctx.fillStyle = '#FF4444';
        ctx.font = 'bold 24px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('‚ö°', this.x, this.y);
      }
    }
    
    // NEW: Tree class
    class Tree {
      constructor(x, width, height) {
        this.x = x;
        this.width = width;
        this.height = height;
        this.y = GROUND_Y - this.height;
        this.canopyRadius = this.width * 2.5;
        this.canopyCenterY = this.y - this.canopyRadius * 0.25;
        this.trunkColor = '#5D4037';
        this.canopyRingColor = `hsl(120, 55%, ${32 + Math.random() * 6}%)`;
        this.canopyCoreColor = `hsl(90, 50%, ${60 + Math.random() * 8}%)`;
        this.canopyOutlineColor = `hsl(120, 45%, ${24 + Math.random() * 6}%)`;
        this.ringWidth = this.canopyRadius * 0.55;
      }
      draw() {
        const centerX = this.x + this.width / 2;

        ctx.fillStyle = this.trunkColor;
        ctx.fillRect(this.x, this.y, this.width, this.height);

        ctx.strokeStyle = this.canopyRingColor;
        ctx.lineWidth = this.ringWidth;
        ctx.beginPath();
        ctx.arc(centerX, this.canopyCenterY, this.canopyRadius - this.ringWidth / 2, 0, Math.PI * 2);
        ctx.stroke();

        ctx.fillStyle = this.canopyCoreColor;
        ctx.beginPath();
        ctx.arc(centerX, this.canopyCenterY, this.canopyRadius * 0.35, 0, Math.PI * 2);
        ctx.fill();

        ctx.strokeStyle = this.canopyOutlineColor;
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.arc(centerX, this.canopyCenterY, this.canopyRadius - this.ringWidth / 2, 0, Math.PI * 2);
        ctx.stroke();
      }
    }
    
    // NEW: Twig class
    class Twig {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.carriedBy = null;
        this.angle = (Math.random() - 0.5) * 0.5;
        this.length = 25 + Math.random() * 20;
      }
      draw() {
        if (this.carriedBy) return; // Drawn by the bird

        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        ctx.strokeStyle = '#8B4513';
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(-this.length / 2, 0);
        ctx.lineTo(this.length / 2, 0);
        ctx.stroke();
        ctx.restore();
      }
    }
    
    // NEW: Bird nest class
    class BirdNest {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.radius = 60;
        this.twigs = 0;
        this.twigData = [];
      }
      addTwig() {
        this.twigs++;
        recordLargestNest = Math.max(recordLargestNest, this.twigs);
        this.twigData.push({
          offset: (Math.random() - 0.5) * 0.8,
          angle: (Math.random() - 0.5) * 0.6,
          length: 20 + Math.random() * 16
        });
      }
      draw() {
        const spriteWidth = this.radius * 2.6;
        const spriteHeight = spriteWidth * 1.9;
        const spriteX = this.x - spriteWidth / 2;
        const defaultY = this.y - spriteHeight * 0.55;
        const spriteY = Math.min(defaultY, GROUND_Y - spriteHeight + 20);

        let overlayCenterY;
        let badgeBaseY;
        let effectiveWidth;

        if (birdhouseReady) {
          ctx.drawImage(birdhouseSprite, spriteX, spriteY, spriteWidth, spriteHeight);
          overlayCenterY = spriteY + spriteHeight * 0.72;
          badgeBaseY = spriteY + spriteHeight + 20;
          effectiveWidth = spriteWidth;
        } else {
          const bodyWidth = this.radius * 1.3;
          const bodyHeight = this.radius * 1.6;
          const roofHeight = this.radius * 0.9;
          const bodyX = this.x - bodyWidth / 2;
          const bodyY = this.y - bodyHeight * 0.45;

          const poleWidth = bodyWidth * 0.18;
          const groundContactY = GROUND_Y;
          const poleHeight = Math.max(0, groundContactY - (bodyY + bodyHeight));

          const shadowGrad = ctx.createLinearGradient(bodyX, bodyY - roofHeight, bodyX, bodyY + bodyHeight + poleHeight);
          shadowGrad.addColorStop(0, 'rgba(0,0,0,0.08)');
          shadowGrad.addColorStop(1, 'rgba(0,0,0,0)');
          ctx.fillStyle = shadowGrad;
          ctx.fillRect(bodyX - 10, bodyY - roofHeight, bodyWidth + 20, bodyHeight + poleHeight + 20);

          ctx.fillStyle = '#8B5A2B';
          if (poleHeight > 0) {
            ctx.fillRect(this.x - poleWidth / 2, bodyY + bodyHeight, poleWidth, poleHeight);
          }

          const corner = bodyWidth * 0.12;
          const bodyGradient = ctx.createLinearGradient(bodyX, bodyY, bodyX, bodyY + bodyHeight);
          bodyGradient.addColorStop(0, '#fdf9f3');
          bodyGradient.addColorStop(1, '#e1d4c2');

          ctx.beginPath();
          ctx.moveTo(bodyX, bodyY + corner);
          ctx.quadraticCurveTo(bodyX, bodyY, bodyX + corner, bodyY);
          ctx.lineTo(bodyX + bodyWidth - corner, bodyY);
          ctx.quadraticCurveTo(bodyX + bodyWidth, bodyY, bodyX + bodyWidth, bodyY + corner);
          ctx.lineTo(bodyX + bodyWidth, bodyY + bodyHeight - corner);
          ctx.quadraticCurveTo(bodyX + bodyWidth, bodyY + bodyHeight, bodyX + bodyWidth - corner, bodyY + bodyHeight);
          ctx.lineTo(bodyX + corner, bodyY + bodyHeight);
          ctx.quadraticCurveTo(bodyX, bodyY + bodyHeight, bodyX, bodyY + bodyHeight - corner);
          ctx.closePath();
          ctx.fillStyle = bodyGradient;
          ctx.fill();
          ctx.strokeStyle = 'rgba(120, 90, 60, 0.35)';
          ctx.lineWidth = 4;
          ctx.stroke();

          const roofLeft = bodyX - bodyWidth * 0.12;
          const roofRight = bodyX + bodyWidth + bodyWidth * 0.12;
          const roofTop = bodyY - roofHeight;
          const roofGradient = ctx.createLinearGradient(this.x, roofTop, this.x, bodyY);
          roofGradient.addColorStop(0, '#f1b24a');
          roofGradient.addColorStop(1, '#d9822b');
          ctx.beginPath();
          ctx.moveTo(this.x, roofTop);
          ctx.lineTo(roofLeft, bodyY + 6);
          ctx.lineTo(roofRight, bodyY + 6);
          ctx.closePath();
          ctx.fillStyle = roofGradient;
          ctx.fill();
          ctx.strokeStyle = 'rgba(130, 80, 25, 0.6)';
          ctx.lineWidth = 4;
          ctx.stroke();

          const holeY = bodyY + bodyHeight * 0.42;
          const holeRadius = bodyWidth * 0.22;
          ctx.fillStyle = '#2f2a24';
          ctx.beginPath();
          ctx.arc(this.x, holeY, holeRadius, 0, Math.PI * 2);
          ctx.fill();
          ctx.strokeStyle = 'rgba(255,255,255,0.35)';
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.arc(this.x, holeY, holeRadius + 4, 0, Math.PI * 2);
          ctx.stroke();

          const perchY = bodyY + bodyHeight * 0.62;
          const perchWidth = bodyWidth * 0.55;
          ctx.fillStyle = '#b48248';
          ctx.fillRect(this.x - perchWidth / 2, perchY, perchWidth, 6);
          ctx.beginPath();
          ctx.arc(this.x + perchWidth / 2, perchY + 3, 3, 0, Math.PI * 2);
          ctx.fill();

          overlayCenterY = bodyY + bodyHeight * 0.8;
          badgeBaseY = bodyY + bodyHeight + 20;
          effectiveWidth = bodyWidth;
        }

        ctx.save();
        ctx.translate(this.x, overlayCenterY);
        const twigWidth = effectiveWidth * 0.4;
        for (const twig of this.twigData) {
          ctx.save();
          ctx.translate(twig.offset * twigWidth, 0);
          ctx.rotate(twig.angle);
          ctx.strokeStyle = '#8a5a35';
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(-twig.length / 2, 0);
          ctx.lineTo(twig.length / 2, 0);
          ctx.stroke();
          ctx.restore();
        }
        ctx.restore();

        const badgeWidth = effectiveWidth * 0.55;
        const badgeHeight = 26;
        const badgeX = this.x - badgeWidth / 2;
        const badgeY = badgeBaseY;
        const badgeGrad = ctx.createLinearGradient(badgeX, badgeY, badgeX, badgeY + badgeHeight);
        badgeGrad.addColorStop(0, '#3b82f6');
        badgeGrad.addColorStop(1, '#2563eb');
        const drawBadgePath = () => {
          const r = 12;
          ctx.beginPath();
          ctx.moveTo(badgeX + r, badgeY);
          ctx.lineTo(badgeX + badgeWidth - r, badgeY);
          ctx.quadraticCurveTo(badgeX + badgeWidth, badgeY, badgeX + badgeWidth, badgeY + r);
          ctx.lineTo(badgeX + badgeWidth, badgeY + badgeHeight - r);
          ctx.quadraticCurveTo(badgeX + badgeWidth, badgeY + badgeHeight, badgeX + badgeWidth - r, badgeY + badgeHeight);
          ctx.lineTo(badgeX + r, badgeY + badgeHeight);
          ctx.quadraticCurveTo(badgeX, badgeY + badgeHeight, badgeX, badgeY + badgeHeight - r);
          ctx.closePath();
        };
        ctx.fillStyle = badgeGrad;
        drawBadgePath();
        ctx.fill();
        ctx.strokeStyle = 'rgba(21, 101, 192, 0.8)';
        ctx.lineWidth = 3;
        drawBadgePath();
        ctx.stroke();

        ctx.fillStyle = '#fff';
        ctx.font = 'bold 20px "Segoe UI", sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(`${this.twigs}`, this.x, badgeY + badgeHeight / 2);
      }
    }

    function regenerateTwigPile() {
      const newPile = [];
      for (let i = 0; i < TWIG_PILE_COUNT; i++) {
        const heightFactor = Math.random();
        const twigY = TWIG_PILE_Y - heightFactor * TWIG_PILE_HEIGHT;
        const twigX = TWIG_PILE_X + (Math.random() - 0.5) * TWIG_PILE_WIDTH * (0.7 + 0.3 * heightFactor);
        newPile.push(new Twig(twigX, twigY));
      }
      twigPile = newPile;
    }

    class Brain {
      constructor(inputs, hidden, outputs, weights) {
        this.inputs = inputs;
        this.hidden = hidden;
        this.outputs = outputs;
        if (weights) {
          this.wIH = weights.wIH.map(r => r.slice());
          this.wHO = weights.wHO.map(r => r.slice());
        } else {
          this.wIH = Array.from({length: hidden}, () => 
            Array.from({length: inputs}, () => Math.random() * 2 - 1));
          this.wHO = Array.from({length: outputs}, () => 
            Array.from({length: hidden}, () => Math.random() * 2 - 1));
        }
      }
      forward(inp) {
        const hid = this.wIH.map(row => Math.tanh(row.reduce((s, w, i) => s + w * inp[i], 0)));
        return this.wHO.map(row => Math.tanh(row.reduce((s, w, i) => s + w * hid[i], 0)));
      }
      copy() {
        return new Brain(this.inputs, this.hidden, this.outputs, {wIH: this.wIH, wHO: this.wHO});
      }
      mutate(rate, power) {
        const mut = arr => arr.forEach(row => row.forEach((v, i, a) => {
          if (Math.random() < rate) a[i] += (Math.random() * 2 - 1) * power;
        }));
        mut(this.wIH);
        mut(this.wHO);
      }
      crossover(other, mix = 0.5) {
        const child = new Brain(this.inputs, this.hidden, this.outputs);
        const blend = (a, b) => typeof b === 'number' ? (a * mix + b * (1 - mix)) : a;
        child.wIH = this.wIH.map((row, i) =>
          row.map((val, j) => {
            const otherRow = other && other.wIH ? other.wIH[i] : null;
            const otherVal = otherRow ? otherRow[j] : undefined;
            return blend(val, otherVal);
          })
        );
        child.wHO = this.wHO.map((row, i) =>
          row.map((val, j) => {
            const otherRow = other && other.wHO ? other.wHO[i] : null;
            const otherVal = otherRow ? otherRow[j] : undefined;
            return blend(val, otherVal);
          })
        );
        return child;
      }
    }

    class Bird {
      constructor(type, brain) {
        this.type = type;
        this.typeData = BIRD_TYPES[type];
        // UPDATED Brain: 43 inputs, 4 outputs // @changed
        this.brain = brain || new Brain(43, BIRD_HIDDEN, 4); // @changed
        this.id = birdIdCounter++;
        this.reset();
      }
      reset() {
        this.x = 200 + Math.random() * 400;
        this.y = 200 + Math.random() * 300;
        this.vx = 0;
        this.vy = 0;
        this.alive = true;
        this.energy = 200; // More starting energy
        this.maxEnergy = 200; // Higher max energy
        this.stamina = 100;
        this.maxStamina = 100;
        this.fitness = 0;
        this.hiding = false;
        this.hideSpot = null;
        this.hidingTime = 0;
        this.hideCooldown = 0;
        this.warned = false;
        this.age = 0;
        this.hasTwig = null; // NEW
        this.facing = 1; // NEW
        this.twigLastDist = null;
        this.twigCarryTime = 0;
        this.trail = [];
        this.groundContact = 0;
        this.wallContact = 0;
        this.ceilingContact = 0;
        this.state = 'FORAGE'; // @added
        this.stateTime = 0; // @added
        this.stateLock = 0; // @added
        this.prevProgress = null; // @added
        this.idleTimer = 0; // @added
        this.lastIdlePos = { x: this.x, y: this.y }; // @added
        this.avoidX = 0; // @added
        this.avoidY = 0; // @added
        this.attractX = 0; // @added
        this.attractY = 0; // @added
        this.rayValues = RAY_ANGLES.map(() => 1); // @added
        this.lastThreat = null; // @added
        this.matingCooldown = 0;
      }
      think() {
        if (!this.alive || this.hiding) return;
        
        let closestFood = null;
        let minFoodDist = Infinity;
        for (const f of foodParticles) {
          if (f.eaten) continue;
          const d = Math.hypot(this.x - f.x, this.y - f.y);
          if (d < minFoodDist) {
            minFoodDist = d;
            closestFood = f;
          }
        }
        
        const predInfo = nearestPredator(this.x, this.y); // @added
        let closestPred = predInfo.target; // @added
        let minPredDist = predInfo.dist; // @added
        
        let closestHide = null;
        let minHideDist = Infinity;
        for (const h of hideSpots) {
          if (!h.canHide()) continue;
          const d = Math.hypot(this.x - h.x, this.y - h.y);
          if (d < minHideDist) {
            minHideDist = d;
            closestHide = h;
          }
        }
        
        // NEW: Find nearest twig
        let closestTwig = null; // @changed
        let minTwigDist = Infinity; // @changed
        if (!this.hasTwig) { // @changed
          const twigInfo = nearestTwig(this.x, this.y); // @added
          closestTwig = twigInfo.target; // @added
          minTwigDist = twigInfo.dist; // @added
        } // @changed
        
        // NEW: Distance to nest
        const nestDist = Math.hypot(this.x - birdNest.x, this.y - birdNest.y);
        
        let nearbyBirds = 0;
        for (const b of birds) {
          if (b === this || !b.alive || b.hiding) continue;
          const d = Math.hypot(this.x - b.x, this.y - b.y);
          if (d < 100) nearbyBirds++;
        }
        
        this.warned = closestPred && minPredDist < ALARM_RANGE;

        const headingMag = Math.hypot(this.vx, this.vy);
        let dirX = this.vx;
        let dirY = this.vy;
        if (headingMag < 0.1) {
          dirX = this.facing; // @changed
          dirY = 0; // @changed
        }
        const dirLen = Math.hypot(dirX, dirY) || 1;
        const normDirX = dirX / dirLen;
        const normDirY = dirY / dirLen;
        const aimAngle = Math.atan2(normDirY, normDirX); // @added

        this.rayValues = RAY_ANGLES.map(offset => sampleRay(this.x, this.y, aimAngle + offset)); // @added
        let avoidX = 0; // @added
        let avoidY = 0; // @added
        this.rayValues.forEach((val, idx) => { // @added
          const urgency = Math.max(0, SAFE_PRED_N - val); // @changed
          if (urgency <= 0) return; // @added
          const angle = aimAngle + RAY_ANGLES[idx]; // @added
          avoidX -= Math.cos(angle) * (urgency / SAFE_PRED_N); // @changed
          avoidY -= Math.sin(angle) * (urgency / SAFE_PRED_N); // @changed
        }); // @added
        this.avoidX = avoidX * AVOID_GAIN_F; // @added
        this.avoidY = avoidY * AVOID_GAIN_F; // @added

        const wallDist = Math.min(this.x, canvas.width - this.x, this.y, GROUND_Y - this.y);
        const normDist = d => (isFinite(d) ? Math.min(d / RAY_RANGE, 1) : 1); // @changed
        const wallDistNorm = normDist(wallDist);
        const leftWallNorm = normDist(this.x);
        const rightWallNorm = normDist(canvas.width - this.x);
        const ceilingDistNorm = normDist(this.y);
        const groundDistNorm = normDist(GROUND_Y - this.y);

        this.updateBirdState({ // @added
          closestFood,
          minFoodDist,
          closestPred,
          minPredDist,
          closestTwig,
          minTwigDist,
          nestDist,
          wallDistNorm
        }); // @added

        const attract = this.computeAttractionVector({ // @added
          closestFood,
          closestTwig,
          nestDist,
          minTwigDist,
          minFoodDist
        }); // @added
        this.attractX = attract.x; // @added
        this.attractY = attract.y; // @added

        telemetry.birdStateTime[this.state] += 1; // @added

        const frontTreeNorm = this.rayValues[0]; // @added
        const leftTreeNorm = this.rayValues[1]; // @added
        const rightTreeNorm = this.rayValues[2]; // @added

        // UPPDATERAD: 43 inputs // @changed
        const forcedRecall = this.forcedReturn > 0; // @added
        const frontRay = this.rayValues[0]; // @added
        const leftRay = this.rayValues[1]; // @added
        const rightRay = this.rayValues[2]; // @added
        const flankRay = this.rayValues[3]; // @added
        const rearLeftRay = this.rayValues[4]; // @added
        const backRay = this.rayValues[5]; // @added

        const inputs = [
          this.x / canvas.width,
          this.y / canvas.height,
          this.vx / 10,
          this.vy / 10,
          this.energy / this.maxEnergy,
          this.stamina / this.maxStamina,
          closestFood ? (closestFood.x - this.x) / canvas.width : 0,
          closestFood ? (closestFood.y - this.y) / canvas.height : 0,
          closestFood ? minFoodDist / 1000 : 1,
          closestPred ? (closestPred.x - this.x) / canvas.width : 0,
          closestPred ? (closestPred.y - this.y) / canvas.height : 0,
          closestPred ? minPredDist / 500 : 1,
          closestHide ? (closestHide.x - this.x) / canvas.width : 0,
          closestHide ? (closestHide.y - this.y) / canvas.height : 0,
          closestHide ? minHideDist / 500 : 1,
          nearbyBirds / 10,
          this.warned ? 1 : 0,
          this.hiding ? 1 : 0,
          this.hidingTime / MAX_HIDE_TIME,
          this.hideCooldown / HIDE_COOLDOWN,
          this.hideCooldown > 0 ? 1 : 0,
          this.age / 1000,
          // NYA INPUTS
          this.hasTwig ? 1 : 0, // 23
          closestTwig ? (closestTwig.x - this.x) / canvas.width : 0, // 24
          closestTwig ? (closestTwig.y - this.y) / canvas.height : 0, // 25
          closestTwig ? minTwigDist / 1000 : 1, // 26
          (birdNest.x - this.x) / canvas.width, // 27
          (birdNest.y - this.y) / canvas.height, // 28
          nestDist / 1000, // 29
          frontTreeNorm, // 30
          leftTreeNorm, // 31
          rightTreeNorm, // 32
          wallDistNorm, // 33
          leftWallNorm, // 34
          rightWallNorm, // 35
          ceilingDistNorm, // 36
          groundDistNorm, // 37
          ...this.rayValues // 38-43 // @added
        ];

        // UPDATED: 4 outputs
        const outputs = this.brain.forward(inputs);
        this.moveX = outputs[0];
        this.moveY = outputs[1];
        this.wantHide = outputs[2] > 0.3;
        this.wantTwig = outputs[3] > 0.3; // NEW
      }
      updateBirdState(ctx) { // @added
        if (this.stateLock > 0) this.stateLock--; // @added
        this.stateTime++; // @added
        const threatClose = ctx.closestPred && ctx.minPredDist < ALARM_RANGE * 0.75; // @added
        const threatGone = !ctx.closestPred || ctx.minPredDist > ALARM_RANGE * 1.2; // @added
        if (threatClose) { // @added
          this.lastThreat = ctx.closestPred; // @added
          if (this.state !== 'EVADE' && this.stateLock === 0) { // @added
            this.state = 'EVADE'; // @added
            this.stateTime = 0; // @added
            this.stateLock = 20; // @added
          } // @added
          return; // @added
        }
        if (this.state === 'EVADE' && !threatClose) { // @added
          if (threatGone && this.stateLock === 0) { // @added
            this.state = this.hasTwig ? 'RETURN_HOME' : 'FORAGE'; // @added
            this.stateTime = 0; // @added
            this.stateLock = 18; // @added
          } // @added
          return; // @added
        }

        let desired = this.state; // @added
        if (this.hasTwig) { // @added
          desired = 'RETURN_HOME'; // @added
        } else if (ctx.closestTwig && (this.wantTwig || ctx.minTwigDist < 260)) { // @added
          desired = 'COLLECT_TWIG'; // @added
        } else if (this.energy < this.maxEnergy * 0.45) { // @added
          desired = 'FORAGE'; // @added
        } else if (ctx.closestTwig) { // @added
          desired = 'COLLECT_TWIG'; // @added
        } else { // @added
          desired = 'FORAGE'; // @added
        }

        if (desired !== this.state && this.stateLock === 0) { // @added
          this.state = desired; // @added
          this.stateTime = 0; // @added
          this.stateLock = 14; // @added
          this.prevProgress = null; // @added
        } // @added
      }
      computeAttractionVector(ctx) { // @added
        let tx = 0; // @added
        let ty = 0; // @added
        if (this.state === 'EVADE' && this.lastThreat) { // @added
          const dx = this.x - this.lastThreat.x; // @added
          const dy = this.y - this.lastThreat.y; // @added
          const dist = Math.hypot(dx, dy) || 1; // @added
          tx += dx / dist; // @added
          ty += dy / dist; // @added
        } else if (this.state === 'COLLECT_TWIG' && ctx.closestTwig) { // @added
          const dx = ctx.closestTwig.x - this.x; // @added
          const dy = ctx.closestTwig.y - this.y; // @added
          const dist = Math.hypot(dx, dy) || 1; // @added
          tx += dx / dist; // @added
          ty += dy / dist; // @added
          if (this.prevProgress != null) { // @added
            this.fitness += (this.prevProgress - dist) * k_b1; // @added
          } // @added
          this.prevProgress = dist; // @added
        } else if (this.state === 'RETURN_HOME') { // @added
          const dx = birdNest.x - this.x; // @added
          const dy = birdNest.y - this.y; // @added
          const dist = Math.hypot(dx, dy) || 1; // @added
          tx += dx / dist; // @added
          ty += dy / dist; // @added
          if (this.prevProgress != null) { // @added
            this.fitness += (this.prevProgress - dist) * k_b1; // @added
          } // @added
          this.prevProgress = dist; // @added
        } else { // @added
          if (ctx.closestFood) { // @added
            const dx = ctx.closestFood.x - this.x; // @added
            const dy = ctx.closestFood.y - this.y; // @added
            const dist = Math.hypot(dx, dy) || 1; // @added
            tx += dx / dist; // @added
            ty += dy / dist; // @added
          } else { // @added
            tx += Math.cos(globalTime * 0.01 + this.age * 0.02); // @added
            ty += Math.sin(globalTime * 0.01 + this.age * 0.02); // @added
          } // @added
          this.prevProgress = null; // @added
        }
        const mag = Math.hypot(tx, ty); // @added
        if (mag > 0) { // @added
          tx = (tx / mag) * 0.6; // @added
          ty = (ty / mag) * 0.6; // @added
        } // @added
        return { x: tx, y: ty }; // @added
      }
      update() {
        if (!this.alive) return;

        if (!this.trail) this.trail = [];

        this.age++;
        recordLongestLife = Math.max(recordLongestLife, this.age);

        if (this.vx > 0.1) this.facing = 1;
        else if (this.vx < -0.1) this.facing = -1;

        const idleMove = Math.hypot(this.x - this.lastIdlePos.x, this.y - this.lastIdlePos.y); // @added
        if (idleMove < 3) { // @added
          this.idleTimer++; // @added
        } else { // @added
          this.idleTimer = 0; // @added
          this.lastIdlePos = { x: this.x, y: this.y }; // @added
        } // @added
        if (this.idleTimer > IDLE_FRAME_LIMIT) { // @added
          const angle = Math.random() * Math.PI * 2; // @added
          const nudge = 0.8 + Math.random() * 0.6; // @added
          this.vx += Math.cos(angle) * nudge; // @added
          this.vy += Math.sin(angle) * nudge * 0.6; // @added
          this.fitness -= k_b4; // @added
          telemetry.idleBreaks += 1; // @added
          this.idleTimer = 0; // @added
          this.lastIdlePos = { x: this.x, y: this.y }; // @added
        } // @added

        if (this.matingCooldown > 0) {
          this.matingCooldown--;
        }

        // Cooldown counter
        if (this.hideCooldown > 0) {
          this.hideCooldown--;
        }
        
        // Hide spot logic
        if (this.hiding) {
          this.trail = [];
          this.hidingTime++;
          this.energy = Math.min(this.energy + 1.5, this.maxEnergy); 
          this.stamina = Math.min(this.stamina + 3, this.maxStamina);
          this.fitness -= HIDE_PENALTY * 0.1;
          
          if (this.hidingTime >= MAX_HIDE_TIME) {
            this.hiding = false;
            if (this.hideSpot) {
              this.hideSpot.removeBird(this);
              this.hideSpot = null;
            }
            this.hidingTime = 0;
            this.hideCooldown = HIDE_COOLDOWN;
          }
          return;
        }
        
        // NEW: Twig logic
        if (this.hasTwig) {
          // Fly to the nest
          const distToNest = Math.hypot(this.x - birdNest.x, this.y - birdNest.y);
          if (this.twigLastDist === null) {
            this.twigLastDist = distToNest;
          } else {
            const progress = this.twigLastDist - distToNest;
            if (progress > 0) {
              this.fitness += progress * TWIG_PROGRESS_FACTOR;
            } else if (progress < 0) {
              this.fitness += progress * TWIG_BACKTRACK_FACTOR;
            }
          }
          this.twigCarryTime++;
          if (this.twigCarryTime > 0 && this.twigCarryTime % TWIG_IDLE_INTERVAL === 0) {
            this.fitness -= TWIG_IDLE_PENALTY;
          }
          this.twigLastDist = distToNest;

          if (distToNest < birdNest.radius + 15) {
            // Twig delivered!
            birdNest.addTwig();
            if (this.hasTwig) this.hasTwig.carriedBy = null;
            twigPile = twigPile.filter(t => t !== this.hasTwig); // Remove the twig permanently
            this.hasTwig = null;
            this.twigLastDist = null;
            this.twigCarryTime = 0;
            this.fitness += TWIG_FITNESS_BONUS;
            twigsInNest++;
            recordLargestNest = Math.max(recordLargestNest, twigsInNest);
            telemetry.twigDeliveries += 1; // @added
            this.fitness += k_b2; // @added
            this.prevProgress = null; // @added
          }
        } else if (!this.hasTwig) {
          // Always pick up a twig when entering the pile
          for (const t of twigPile) {
            if (!t.carriedBy && Math.hypot(this.x - t.x, this.y - t.y) < 35) {
              this.hasTwig = t;
              t.carriedBy = this;
              this.twigLastDist = Math.hypot(this.x - birdNest.x, this.y - birdNest.y);
              this.twigCarryTime = 0;
              this.fitness += TWIG_FITNESS_BONUS * TWIG_PICKUP_RATIO;
              break;
            }
          }
        }

        // Try to hide IF the cooldown is over (and we're not carrying a twig?)
        // Birds carrying twigs might not want to hide? Let the brain decide.
        if (this.wantHide && this.hideCooldown === 0 && !this.hasTwig) {
          for (const h of hideSpots) {
            const d = Math.hypot(this.x - h.x, this.y - h.y);
            if (d < h.radius + 10 && h.canHide()) {
              if (h.addBird(this)) {
                this.hiding = true;
                this.hideSpot = h;
                this.x = h.x;
                this.y = h.y;
                this.trail = [];
                return;
              }
            }
          }
        }
        
        this.energy -= ENERGY_MOVE_COST;
        this.stamina -= STAMINA_COST * 0.05;
        
        let speedMult = this.typeData.speed;
        const grounded = this.y >= GROUND_Y - 2 && Math.abs(this.vy) < 1.2;
        if (grounded) speedMult *= 0.35;
        if (this.stamina < 20) speedMult *= 0.5;
        if (this.warned) speedMult *= (1 + WARN_BOOST);
        if (this.hasTwig) speedMult *= 0.8; // Slower with a twig
        
        const steerX = (this.moveX * MIX_OUTPUT) + this.avoidX + this.attractX; // @added
        const steerY = (this.moveY * MIX_OUTPUT) + this.avoidY + this.attractY; // @added
        this.vx += steerX * 0.7 * speedMult; // @changed
        this.vy += steerY * 0.7 * speedMult; // @changed
        
        const moveSpeed = Math.hypot(this.vx, this.vy);
        if (moveSpeed > 5) {
          this.stamina -= STAMINA_COST * 0.1;
          this.energy -= ENERGY_MOVE_COST * 0.5;
        }
        
        this.vy += 0.2;
        this.vx *= 0.97;
        this.vy *= 0.97;

        const maxSpeed = 8 * speedMult;
        const speed = Math.hypot(this.vx, this.vy);
        if (speed > maxSpeed) {
          this.vx = (this.vx / speed) * maxSpeed;
          this.vy = (this.vy / speed) * maxSpeed;
        }
        
        this.x += this.vx;
        this.y += this.vy;

        const wallDistance = Math.min(this.x, canvas.width - this.x, this.y, GROUND_Y - this.y); // @added
        const wallSafety = wallDistance / RAY_RANGE; // @added
        this.fitness += wallSafety * k_b3; // @added
        telemetry.avgWallDist = telemetry.avgWallDist * 0.98 + wallDistance * 0.02; // @added
        
        // Wall collision
        let hitLeftWall = false;
        let hitRightWall = false;
        let hitCeiling = false;
        let hitGround = false;

        if (this.x < 0) { this.x = 0; this.vx = Math.abs(this.vx); hitLeftWall = true; }
        if (this.x > canvas.width) { this.x = canvas.width; this.vx = -Math.abs(this.vx); hitRightWall = true; }
        if (this.y < 0) { this.y = 0; this.vy = Math.abs(this.vy); hitCeiling = true; }
        if (this.y > GROUND_Y) { this.y = GROUND_Y; this.vy = -Math.abs(this.vy) * 0.6; hitGround = true; }
        
        // NEW: Tree collision
        for (const tree of trees) {
          const birdRadiusX = 8;
          const birdRadiusY = 6;
          if (this.x + birdRadiusX > tree.x &&
              this.x - birdRadiusX < tree.x + tree.width &&
              this.y + birdRadiusY > tree.y) {
            
            // Colliding. Check if we hit the top
            if (this.y - birdRadiusY < tree.y && this.vy > 0) {
              this.y = tree.y - birdRadiusY;
              this.vy = -Math.abs(this.vy) * 0.3; // Bounce off the top
            } else { // Hit the side
              if (this.vx > 0) { // Moving right
                this.x = tree.x - birdRadiusX;
                this.vx = -Math.abs(this.vx) * 0.5;
              } else { // Moving left
                this.x = tree.x + tree.width + birdRadiusX;
                this.vx = Math.abs(this.vx) * 0.5;
              }
            }
          }
        }

        if (hitLeftWall || hitRightWall) {
          telemetry.birdWallCrashes += 1; // @added
          const push = hitLeftWall ? 1 : -1; // @added
          this.vx += push * 0.6; // @added
          this.wallContact++;
          const contactSeverity = 1 + this.wallContact * 0.2;
          this.fitness -= WALL_PENALTY_BASE * contactSeverity;
          this.energy = Math.max(0, this.energy - WALL_PENALTY_ENERGY * contactSeverity);
          this.energy = applyCollisionPenalty(
            this.energy,
            WALL_PENALTY_ENERGY * contactSeverity,
            COLLISION_ENERGY_FLOOR
          );
          this.energy = Math.max(0, this.energy - WALL_PENALTY_ENERGY * 0.4); // @added
        } else {
          this.wallContact = 0;
        }

        if (hitCeiling) {
          this.ceilingContact++;
          const severity = 1 + this.ceilingContact * 0.3;
          this.fitness -= CEILING_PENALTY_BASE * severity;
          this.energy = Math.max(0, this.energy - CEILING_PENALTY_ENERGY * severity);
          this.stamina = Math.max(0, this.stamina - 4 * severity);
          this.energy = applyCollisionPenalty(
            this.energy,
            CEILING_PENALTY_ENERGY * severity,
            COLLISION_ENERGY_FLOOR
          );
          this.stamina = applyCollisionPenalty(
            this.stamina,
            4 * severity,
            COLLISION_STAMINA_FLOOR
          );
        } else if (this.y <= 10) {
          // Close to the ceiling without a direct hit still hurts
          this.ceilingContact = Math.max(0, this.ceilingContact - 1);
          this.fitness -= CEILING_PENALTY_BASE * 0.2;
        } else {
          this.ceilingContact = 0;
        }

        const groundGap = GROUND_Y - this.y;
        if (hitGround || groundGap <= 4) {
          this.groundContact++;
          const severity = 1 + Math.max(0, 4 - groundGap) * 0.8 + this.groundContact * 0.25;
          this.fitness -= GROUND_PENALTY_BASE * severity;
          this.energy = Math.max(0, this.energy - GROUND_PENALTY_ENERGY * severity);
          this.stamina = Math.max(0, this.stamina - GROUND_PENALTY_STAMINA * severity);
          this.energy = applyCollisionPenalty(
            this.energy,
            GROUND_PENALTY_ENERGY * severity,
            COLLISION_ENERGY_FLOOR
          );
          this.stamina = applyCollisionPenalty(
            this.stamina,
            GROUND_PENALTY_STAMINA * severity,
            COLLISION_STAMINA_FLOOR
          );
        } else {
          this.groundContact = 0;
        }

        if (this.trail.length > 25) {
          this.trail.shift();
        }
        this.trail.push({ x: this.x, y: this.y });

        // Food collision
        for (const f of foodParticles) {
          if (f.eaten) continue;
          const d = Math.hypot(this.x - f.x, this.y - f.y);
          if (d < 15) {
            f.eaten = true;
            this.energy = Math.min(this.energy + FOOD_VALUE, this.maxEnergy);
            for (let i = 0; i < 5; i++) {
              particles.push(new Particle(f.x, f.y, '#8BC34A'));
            }
          }
        }
        
        if (this.alive) {
          this.fitness += 1;
          this.fitness += (this.energy / this.maxEnergy) * 0.3;
          if (!this.hiding) this.fitness += 0.5;
          
          const margin = 30;
          const notTouchingWalls = this.x > margin && this.x < canvas.width - margin && 
                                   this.y > margin && this.y < GROUND_Y - margin;
          if (notTouchingWalls) {
            this.fitness += 5;
          }
          
          let nearby = 0;
          for (const b of birds) {
            if (b === this || !b.alive || b.hiding) continue;
            if (Math.hypot(this.x - b.x, this.y - b.y) < 80) nearby++;
          }
          this.fitness += nearby * this.typeData.stamina * 0.1;
        }
        
        if (this.energy <= 0 || this.stamina <= 0) {
          this.alive = false;
          this.fitness = Math.max(0, this.fitness - 400);
          if (this.hasTwig) { // Drop twig on death
            this.fitness = Math.max(0, this.fitness - TWIG_FITNESS_BONUS * TWIG_DEATH_RATIO);
            this.hasTwig.carriedBy = null;
            this.hasTwig = null;
            this.twigLastDist = null;
            this.twigCarryTime = 0;
          }
          this.trail = [];
        }
        
        if (this.warned && globalTime % 30 === 0) {
          alarmWaves.push(new AlarmWave(this.x, this.y));
        }

        recordBestFitness = Math.max(recordBestFitness, this.fitness);
      }
      draw() {
        if (this.trail && this.trail.length > 1) {
          ctx.save();
          ctx.lineWidth = 3;
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';
          for (let i = 1; i < this.trail.length; i++) {
            const prev = this.trail[i - 1];
            const curr = this.trail[i];
            const alpha = i / this.trail.length;
            ctx.strokeStyle = this.typeData.color;
            ctx.globalAlpha = alpha * 0.45;
            ctx.beginPath();
            ctx.moveTo(prev.x, prev.y);
            ctx.lineTo(curr.x, curr.y);
            ctx.stroke();
          }
          ctx.restore();
        }

        if (!this.alive || this.hiding) return;

        ctx.save();
        ctx.translate(this.x, this.y);
        
        if (this.facing < 0) ctx.scale(-1, 1);
        
        if (this.warned) {
          ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(0, 0, 18, 0, Math.PI * 2);
          ctx.stroke();
        }
        
        if (this.hideCooldown > 0) {
          const cooldownPct = clamp(this.hideCooldown / HIDE_COOLDOWN);
          ctx.strokeStyle = `rgba(255, 100, 100, ${cooldownPct})`;
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.arc(0, 0, 15, 0, Math.PI * 2);
          ctx.stroke();
        }
        
        ctx.fillStyle = 'rgba(0,0,0,0.2)';
        ctx.beginPath();
        ctx.ellipse(0, 10, 8, 3, 0, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = this.typeData.color;
        ctx.beginPath();
        ctx.ellipse(0, 0, 9, 6, 0, 0, Math.PI * 2);
        ctx.fill();
        
        const flap = Math.sin(this.age * 0.25) * 0.4;
        ctx.save();
        ctx.rotate(flap);
        ctx.fillStyle = this.typeData.color;
        ctx.fillRect(-10, -2, 6, 2);
        ctx.restore();
        
        ctx.save();
        ctx.rotate(-flap);
        ctx.fillStyle = this.typeData.color;
        ctx.fillRect(4, -2, 6, 2);
        ctx.restore();
        
        ctx.fillStyle = this.typeData.color;
        ctx.beginPath();
        ctx.arc(6, -2, 3.5, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = this.warned ? '#FF0000' : '#000';
        ctx.beginPath();
        ctx.arc(7, -2.5, 1, 0, Math.PI * 2);
        ctx.fill();
        
        // NYTT: Rita kvist
        if (this.hasTwig) {
          ctx.strokeStyle = '#8B4513';
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(8, -1);
          ctx.lineTo(20, 0);
          ctx.stroke();
        }
        
        const ep = clamp(this.energy / this.maxEnergy);
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.fillRect(-9, -12, 18, 2);
        ctx.fillStyle = ep > 0.5 ? '#4CAF50' : ep > 0.25 ? '#FFA500' : '#FF4444';
        ctx.fillRect(-9, -12, 18 * ep, 2);

        const sp = clamp(this.stamina / this.maxStamina);
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.fillRect(-9, -15, 18, 2);
        ctx.fillStyle = sp > 0.5 ? '#2196F3' : sp > 0.25 ? '#FFA500' : '#FF4444';
        ctx.fillRect(-9, -15, 18 * sp, 2);
        
        ctx.restore();
      }
    }
    
    class Predator {
      constructor(brain) {
        this.brain = brain || new Brain(26, PRED_HIDDEN, 3); // @changed
        this.reset();
      }
      reset() {
        const nest = predNests.length
          ? predNests[Math.floor(Math.random() * predNests.length)]
          : { x: canvas.width - 220, y: 160, radius: 60 };
        this.x = nest.x;
        this.y = nest.y;
        this.homeNest = nest;
        this.vx = 0;
        this.vy = 0;
        this.alive = true;
        this.inNest = true;
        this.energy = PRED_BASE_ENERGY;
        this.maxEnergy = PRED_MAX_ENERGY;
        this.fitness = 0;
        this.kills = 0;
        this.nestTime = 0;
        this.huntBonus = 0;
        this.facing = -1; // NYTT
        this.prevTargetDist = null;
        this.prevNestDist = null;
        this.forcedReturn = 0;
        this.wallCrashTimer = 0;
        this.cornerStall = 0;
        this.nestCooldown = 0;
        this.state = 'NEST'; // @added
        this.stateTime = 0; // @added
        this.stateLock = 0; // @added
        this.rayValues = RAY_ANGLES.map(() => 1); // @added
        this.avoidX = 0; // @added
        this.avoidY = 0; // @added
        this.attractX = 0; // @added
        this.attractY = 0; // @added
        this.idleTimer = 0; // @added
        this.lastIdlePos = { x: this.x, y: this.y }; // @added
      }
      enterNest() {
        this.inNest = true;
        this.nestTime = 0;
        this.nestCooldown = 0;
        this.vx = 0;
        this.vy = 0;
        this.x = this.homeNest.x;
        this.y = this.homeNest.y;
        this.prevTargetDist = null;
        this.prevNestDist = null;
        this.state = 'NEST'; // @added
        this.stateTime = 0; // @added
        this.avoidX = 0; // @added
        this.avoidY = 0; // @added
        this.attractX = 0; // @added
        this.attractY = 0; // @added
      }
      exitNest(force = false) {
        this.inNest = false;
        this.nestTime = 0;
        this.nestCooldown = Math.max(this.nestCooldown, PRED_NEST_COOLDOWN);
        const angle = -Math.PI / 2 + (Math.random() - 0.5) * Math.PI * 0.6;
        const pushDist = this.homeNest.radius + 24;
        const targetX = this.homeNest.x + Math.cos(angle) * pushDist;
        const targetY = this.homeNest.y + Math.sin(angle) * pushDist;
        this.x = Math.min(canvas.width - 16, Math.max(16, targetX));
        this.y = Math.min(GROUND_Y - 20, Math.max(16, targetY));
        this.vx = Math.cos(angle) * 2.5;
        this.vy = Math.sin(angle) * 2.5;
        if (force && this.energy < this.maxEnergy * PRED_FORCED_EXIT_MIN_RATIO) {
          this.energy = this.maxEnergy * PRED_FORCED_EXIT_MIN_RATIO;
        }
        this.prevTargetDist = null;
        this.prevNestDist = null;
        this.state = 'SEARCH'; // @added
        this.stateTime = 0; // @added
        this.avoidX = 0; // @added
        this.avoidY = 0; // @added
        this.attractX = 0; // @added
        this.attractY = 0; // @added
      }
      update() {
        if (!this.alive) return;
        if (!this.inNest && this.nestCooldown > 0) {
          this.nestCooldown--;
        }
        if (this.vx > 0.1) this.facing = 1;
        else if (this.vx < -0.1) this.facing = -1;

        const idleMove = Math.hypot(this.x - this.lastIdlePos.x, this.y - this.lastIdlePos.y); // @added
        if (idleMove < 4) { // @added
          this.idleTimer++; // @added
        } else { // @added
          this.idleTimer = 0; // @added
          this.lastIdlePos = { x: this.x, y: this.y }; // @added
        } // @added
        if (this.idleTimer > IDLE_FRAME_LIMIT) { // @added
          const angle = Math.random() * Math.PI * 2; // @added
          this.vx += Math.cos(angle) * 1.2; // @added
          this.vy += Math.sin(angle) * 0.8; // @added
          this.fitness -= k_p1 * 10; // @added
          telemetry.idleBreaks += 1; // @added
          this.idleTimer = 0; // @added
          this.lastIdlePos = { x: this.x, y: this.y }; // @added
        } // @added

        if (this.inNest) {
          this.nestTime++;
          this.energy = Math.min(this.energy + NEST_CHARGE_RATE, this.maxEnergy);
          this.prevTargetDist = null;
          this.prevNestDist = null;
          if (this.wallCrashTimer > 0) this.wallCrashTimer--;
          if (this.forcedReturn > 0 && this.energy >= this.maxEnergy * 0.95) {
            this.forcedReturn = 0;
            this.cornerStall = 0;
          }

          telemetry.predStateTime.NEST += 1; // @added

          if (this.nestTime >= PRED_NEST_MAX_TIME) {
            this.exitNest(true);
            return;
          }
          if (this.energy >= this.maxEnergy && this.nestTime > 20) {
            this.exitNest();
            return;
          }
          return;
        }

        this.energy -= PRED_ACTIVE_ENERGY_DRAIN;
        if (this.checkEnergy()) return;
        if (this.wallCrashTimer > 0) this.wallCrashTimer--;
        if (this.forcedReturn > 0) this.forcedReturn--;

        const huntInfo = nearestBird(this.x, this.y); // @added
        let target = huntInfo.target; // @added
        let minDist = huntInfo.dist; // @added

        const previousTargetDist = target ? (this.prevTargetDist ?? minDist) : null;

        let packMates = 0;
        if (PACK_HUNT && target) {
          for (const p of predators) {
            if (p === this || p.inNest || !p.alive) continue;
            const d = Math.hypot(this.x - p.x, this.y - p.y);
            if (d < 200) packMates++;
          }
        }

        const distToNest = Math.hypot(this.x - this.homeNest.x, this.y - this.homeNest.y);
        const previousNestDist = this.prevNestDist ?? distToNest;

        const headingMag = Math.hypot(this.vx, this.vy);
        let dirX = this.vx;
        let dirY = this.vy;
        if (headingMag < 0.1) {
          if (target) {
            dirX = target.x - this.x;
            dirY = target.y - this.y;
          } else {
            dirX = this.facing;
            dirY = 0;
          }
        }
        const dirLen = Math.hypot(dirX, dirY) || 1;
        const normDirX = dirX / dirLen;
        const normDirY = dirY / dirLen;
        const aimAngle = Math.atan2(normDirY, normDirX); // @added

        this.rayValues = RAY_ANGLES.map(offset => sampleRay(this.x, this.y, aimAngle + offset)); // @added
        let avoidX = 0; // @added
        let avoidY = 0; // @added
        this.rayValues.forEach((val, idx) => { // @added
          const urgency = Math.max(0, SAFE_PRED_N - val); // @added
          if (urgency <= 0) return; // @added
          const angle = aimAngle + RAY_ANGLES[idx]; // @added
          avoidX -= Math.cos(angle) * (urgency / SAFE_PRED_N); // @added
          avoidY -= Math.sin(angle) * (urgency / SAFE_PRED_N); // @added
        }); // @added
        this.avoidX = avoidX * AVOID_GAIN_P; // @added
        this.avoidY = avoidY * AVOID_GAIN_P; // @added

        const wallDist = Math.min(this.x, canvas.width - this.x, this.y, GROUND_Y - this.y); // @added
        const normTree = d => (isFinite(d) ? Math.min(d / RAY_RANGE, 1) : 1); // @changed
        const wallDistNorm = normTree(wallDist); // @changed

        this.updatePredState({ // @added
          target,
          minDist,
          packMates,
          distToNest,
          forcedReturn: this.forcedReturn > 0,
          energy: this.energy
        }); // @added
        const attraction = this.computePredAttraction({ // @added
          target,
          minDist,
          packMates,
          distToNest,
          aimAngle
        }); // @added
        this.attractX = attraction.x; // @added
        this.attractY = attraction.y; // @added

        const frontRay = this.rayValues[0]; // @added
        const leftRay = this.rayValues[1]; // @added
        const rightRay = this.rayValues[2]; // @added
        const flankRay = this.rayValues[3]; // @added
        const rearLeftRay = this.rayValues[4]; // @added
        const backRay = this.rayValues[5]; // @added
        const forcedRecall = this.forcedReturn > 0; // @added
        telemetry.predStateTime[this.state] += 1; // @added

        if (wallDist < PRED_CORNER_WARN_DIST) {
          const severity = 1 - Math.min(wallDist / PRED_CORNER_WARN_DIST, 1);
          this.energy = Math.max(0, this.energy - PRED_CORNER_ENERGY_DRAIN * severity);
          this.fitness -= PRED_CORNER_FITNESS_DRAIN * severity;
          this.cornerStall += 1 + severity;
        } else {
          this.cornerStall = Math.max(0, this.cornerStall - 1);
        }
        if (this.checkEnergy()) return;
        if (this.cornerStall > 18) {
          this.forcedReturn = Math.max(this.forcedReturn, Math.floor(PRED_WALL_FORCED_RETURN * 0.6));
        }

        if (previousTargetDist !== null && target) { // @added
          this.fitness += (previousTargetDist - minDist) * k_p1; // @added
        } // @added
        if (this.state === 'FLANK' || this.state === 'AMBUSH') { // @added
          this.fitness += k_p2; // @added
        } // @added

        const inputs = [
          this.x / canvas.width,
          this.y / canvas.height,
          this.vx / 10,
          this.vy / 10,
          this.energy / this.maxEnergy,
          target ? (target.x - this.x) / canvas.width : 0,
          target ? (target.y - this.y) / canvas.height : 0,
          target ? minDist / 1000 : 1,
          (this.homeNest.x - this.x) / canvas.width,
          (this.homeNest.y - this.y) / canvas.height,
          distToNest / 1000,
          this.kills / 10,
          packMates / 5,
          birds.filter(b => b.alive && !b.hiding).length / BIRD_COUNT,
          this.inNest ? 1 : 0,
          this.huntBonus,
          frontRay,
          leftRay,
          rightRay,
          wallDistNorm,
          flankRay,
          rearLeftRay,
          backRay,
          forcedRecall ? 1 : 0,
          this.state === 'CHASE' ? 1 : 0,
          this.state === 'RETREAT' ? 1 : 0
        ];

        const outputs = this.brain.forward(inputs);

        const evolutionBonus = PRED_EVOLVE ? (1 + this.huntBonus * 0.1) : 1;
        const packBonus = PACK_HUNT ? (1 + packMates * 0.1) : 1;
        const recallThrottle = forcedRecall ? 0.55 : 1;
        const moveX = outputs[0] * 0.8 * evolutionBonus * packBonus * recallThrottle; // @changed
        const moveY = outputs[1] * 0.8 * evolutionBonus * packBonus * recallThrottle; // @changed
        let wantNest = outputs[2] > 0.4;
        if (forcedRecall || this.energy < this.maxEnergy * 0.25) {
          wantNest = true;
        }
        if (forcedRecall) {
          this.fitness -= 0.5;
        }

        const steerX = moveX * MIX_OUTPUT + this.avoidX + this.attractX; // @added
        const steerY = moveY * MIX_OUTPUT + this.avoidY + this.attractY; // @added
        this.vx += steerX; // @changed
        this.vy += steerY; // @changed
        this.vx *= 0.96;
        this.vy *= 0.96;
        
        const maxSpeed = PRED_SPEED * evolutionBonus * packBonus;
        const speed = Math.hypot(this.vx, this.vy);
        if (speed > maxSpeed) {
          this.vx = (this.vx / speed) * maxSpeed;
          this.vy = (this.vy / speed) * maxSpeed;
        }
        
        this.x += this.vx;
        this.y += this.vy;

        this.fitness += wallDistNorm * k_p2 * 0.5; // @added

        if (this.x < 12) {
          this.x = 12;
          this.vx = Math.abs(this.vx) * 0.25;
          this.applyWallCrash();
          if (!this.alive) return;
        }
        if (this.x > canvas.width - 12) {
          this.x = canvas.width - 12;
          this.vx = -Math.abs(this.vx) * 0.25;
          this.applyWallCrash();
          if (!this.alive) return;
        }
        if (this.y < 12) {
          this.y = 12;
          this.vy = Math.abs(this.vy) * 0.25;
          this.applyWallCrash();
          if (!this.alive) return;
        }
        if (this.y > GROUND_Y - 12) {
          this.y = GROUND_Y - 12;
          this.vx = 0;
          this.vy = 0;
          this.die('ground');
          return;
        }

        this.energy = Math.max(0, this.energy);
        if (this.checkEnergy()) return;

        // NEW: Tree collision for predator
        for (const tree of trees) {
          const predRadiusX = 16;
          const predRadiusY = 10;
          if (this.x + predRadiusX > tree.x &&
              this.x - predRadiusX < tree.x + tree.width &&
              this.y + predRadiusY > tree.y) {
            
            if (this.y - predRadiusY < tree.y && this.vy > 0) {
              this.y = tree.y - predRadiusY;
              this.vy = -Math.abs(this.vy) * 0.3;
              this.fitness -= 8;
            } else {
              if (this.vx > 0) {
                this.x = tree.x - predRadiusX;
                this.vx = -Math.abs(this.vx) * 0.5;
                this.fitness -= 8;
              } else {
                this.x = tree.x + tree.width + predRadiusX;
                this.vx = Math.abs(this.vx) * 0.5;
                this.fitness -= 8;
              }
            }
          }
        }

        for (const f of foodParticles) {
          if (f.eaten) continue;
          const d = Math.hypot(this.x - f.x, this.y - f.y);
          if (d < 18) {
            f.eaten = true;
            this.energy = Math.min(this.energy + FOOD_VALUE, this.maxEnergy);
            for (let i = 0; i < 5; i++) {
              particles.push(new Particle(f.x, f.y, '#8BC34A'));
            }
          }
        }

        const newTargetDist = target ? Math.hypot(this.x - target.x, this.y - target.y) : null;
        if (previousTargetDist !== null && newTargetDist !== null) {
          const chaseDelta = previousTargetDist - newTargetDist;
          if (chaseDelta > 0) {
            this.fitness += chaseDelta * PRED_CHASE_PROGRESS_REWARD;
          } else if (chaseDelta < 0) {
            this.fitness += chaseDelta * PRED_CHASE_PROGRESS_PENALTY;
          }
        } else if (!target) {
          if (birds.some(b => b.alive && !b.hiding)) {
            this.fitness -= 0.6;
          }
        }

        if (target && newTargetDist !== null) {
          const proximity = clamp(1 - newTargetDist / 450, 0, 1);
          this.fitness += proximity * PRED_CHASE_PROXIMITY_BONUS;
          if (speed > maxSpeed * 0.65) {
            this.fitness += proximity * PRED_HIGH_SPEED_REWARD;
          } else if (speed < maxSpeed * 0.25) {
            this.fitness -= 0.6;
          }
        }

        const updatedNestDist = Math.hypot(this.x - this.homeNest.x, this.y - this.homeNest.y);
        const nestDelta = previousNestDist - updatedNestDist;
        if (wantNest || forcedRecall || this.energy < this.maxEnergy * 0.35) {
          if (nestDelta > 0) {
            this.fitness += nestDelta * 0.2;
          } else if (nestDelta < 0) {
            this.fitness += nestDelta * 0.1;
          }
        }

        if (target && newTargetDist !== null && newTargetDist < 180) {
          this.fitness += 2.2;
        }

        if (target && newTargetDist !== null && newTargetDist > 320) {
          this.fitness -= 0.5;
        }

        this.prevNestDist = updatedNestDist;

        for (const b of birds) {
          if (!b.alive || b.hiding) continue;
          const d = Math.hypot(this.x - b.x, this.y - b.y);
          if (d < 18) {
            b.alive = false;
            b.trail = [];
            if (b.hasTwig) { // Drop twig on death
              b.fitness = Math.max(0, b.fitness - TWIG_FITNESS_BONUS * TWIG_DEATH_RATIO);
              b.hasTwig.carriedBy = null;
              b.hasTwig = null;
              b.twigLastDist = null;
              b.twigCarryTime = 0;
            }
            this.energy = Math.min(this.energy + KILL_ENERGY * PRED_KILL_ENERGY_MULTIPLIER, this.maxEnergy);
            this.fitness += KILL_FITNESS;
            this.kills++;
            recordMostKills = Math.max(recordMostKills, this.kills);
            totalEaten++;
            deadThisGen++;
            
            if (PRED_EVOLVE) {
              this.huntBonus += 0.05;
            }
            
            for (let i = 0; i < 20; i++) {
              particles.push(new Particle(b.x, b.y, b.typeData.color));
            }
          }
        }

        this.prevTargetDist = (target && target.alive) ? Math.hypot(this.x - target.x, this.y - target.y) : null;

        const needsNest = wantNest || forcedRecall || this.energy < this.maxEnergy * 0.5;
        const canOverrideCooldown = forcedRecall || this.energy <= this.maxEnergy * 0.15;
        if (needsNest && distToNest < this.homeNest.radius) {
          if (this.nestCooldown <= 0 || canOverrideCooldown) {
            this.enterNest();
          }
        }
      }

      updatePredState(ctx) { // @added
        if (this.stateLock > 0) this.stateLock--; // @added
        if (this.inNest) { // @added
          if (this.state !== 'NEST') { // @added
            this.state = 'NEST'; // @added
            this.stateTime = 0; // @added
            this.stateLock = 10; // @added
          } else { // @added
            this.stateTime++; // @added
          } // @added
          return; // @added
        } // @added
        this.stateTime++; // @added
        let desired = this.state; // @added
        if (ctx.forcedReturn || ctx.energy < this.maxEnergy * 0.3) { // @added
          desired = 'RETREAT'; // @added
        } else if (ctx.target && ctx.minDist < 160) { // @added
          desired = 'CHASE'; // @added
        } else if (ctx.target && ctx.packMates > 0 && ctx.minDist < 320) { // @added
          desired = 'FLANK'; // @added
        } else if (ctx.target && ctx.minDist < 480) { // @added
          desired = 'AMBUSH'; // @added
        } else { // @added
          desired = 'SEARCH'; // @added
        } // @added
        if (this.state === 'RETREAT' && !ctx.forcedReturn && ctx.energy > this.maxEnergy * 0.55) { // @added
          desired = ctx.target ? 'CHASE' : 'SEARCH'; // @added
        } // @added
        if (desired !== this.state && this.stateLock === 0) { // @added
          this.state = desired; // @added
          this.stateTime = 0; // @added
          this.stateLock = 18; // @added
        } // @added
      } // @added

      computePredAttraction(ctx) { // @added
        let ax = 0; // @added
        let ay = 0; // @added
        if (this.state === 'RETREAT') { // @added
          const dx = this.homeNest.x - this.x; // @added
          const dy = this.homeNest.y - this.y; // @added
          const dist = Math.hypot(dx, dy) || 1; // @added
          ax += (dx / dist) * 1.2; // @added
          ay += (dy / dist) * 1.2; // @added
        } else if ((this.state === 'CHASE' || this.state === 'AMBUSH' || this.state === 'FLANK') && ctx.target) { // @added
          const dx = ctx.target.x - this.x; // @added
          const dy = ctx.target.y - this.y; // @added
          const dist = Math.hypot(dx, dy) || 1; // @added
          if (this.state === 'FLANK') { // @added
            const flankAngle = ctx.aimAngle + (this.facing > 0 ? Math.PI / 2 : -Math.PI / 2); // @added
            ax += Math.cos(flankAngle); // @added
            ay += Math.sin(flankAngle); // @added
          } else if (this.state === 'AMBUSH') { // @added
            const leadX = dx + (ctx.target.vx || 0) * 18; // @added
            const leadY = dy + (ctx.target.vy || 0) * 18; // @added
            const leadDist = Math.hypot(leadX, leadY) || 1; // @added
            ax += leadX / leadDist; // @added
            ay += leadY / leadDist; // @added
          } else { // @added
            ax += dx / dist; // @added
            ay += dy / dist; // @added
          } // @added
        } else if (this.state === 'SEARCH') { // @added
          const roamAngle = globalTime * 0.01 + this.x * 0.001 + this.y * 0.001; // @added
          ax += Math.cos(roamAngle) * 0.6; // @added
          ay += Math.sin(roamAngle) * 0.6; // @added
          ax += (this.homeNest.x - this.x) / Math.max(ctx.distToNest, 1) * 0.6; // @added
          ay += (this.homeNest.y - this.y) / Math.max(ctx.distToNest, 1) * 0.6; // @added
        }
        const mag = Math.hypot(ax, ay); // @added
        if (mag > 0) { // @added
          ax = (ax / mag) * 0.8; // @added
          ay = (ay / mag) * 0.8; // @added
        } // @added
        return { x: ax, y: ay }; // @added
      }

      die(cause = 'exhaustion') {
        if (!this.alive) return;
        this.alive = false;
        this.inNest = false;
        this.vx = 0;
        this.vy = 0;
        this.energy = 0;
        this.fitness = Math.max(0, this.fitness - 400);
        this.prevTargetDist = null;
        this.prevNestDist = null;
        this.forcedReturn = 0;
        this.wallCrashTimer = 0;
        this.cornerStall = 0;
        this.nestCooldown = 0;
        for (let i = 0; i < 20; i++) {
          particles.push(new Particle(this.x, this.y, '#9C27B0'));
        }
      }

      checkEnergy() {
        if (this.energy <= 0) {
          this.die('exhaustion');
          return true;
        }
        return false;
      }

      applyWallCrash() {
        if (!this.alive) return;
        if (this.wallCrashTimer > 0) return;
        telemetry.predWallCrashes += 1; // @added
        this.vx += this.x < canvas.width / 2 ? 1.1 : -1.1; // @added
        this.vy -= 0.6; // @added
        this.fitness -= PRED_WALL_CRASH_FITNESS;
        this.energy = Math.max(0, this.energy - this.maxEnergy * 0.3);
        this.energy = Math.min(this.energy, this.maxEnergy * PRED_WALL_CRASH_ENERGY_RATIO);
        if (this.checkEnergy()) return;
        this.forcedReturn = Math.max(this.forcedReturn, PRED_WALL_FORCED_RETURN);
        this.huntBonus = Math.max(0, this.huntBonus - 0.1);
        this.cornerStall = Math.max(this.cornerStall, 12);
        this.wallCrashTimer = 30;
      }

      // NYTT: drawInNest
      drawInNest() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.globalAlpha = 0.6; // Halvgenomskinlig
        
        if (this.facing < 0) ctx.scale(-1, 1);
        
        // Simplified body
        ctx.fillStyle = '#9C27B0';
        ctx.beginPath();
        ctx.ellipse(0, 0, 16, 10, 0, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = '#7B1FA2';
        ctx.beginPath();
        ctx.arc(10, -3, 5, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = '#FF0000';
        ctx.beginPath();
        ctx.arc(12, -4, 2.5, 0, Math.PI * 2);
        ctx.fill();
        
        // Energibar
        const ep = clamp(this.energy / this.maxEnergy);
        ctx.fillStyle = 'rgba(0,0,0,0.4)';
        ctx.fillRect(-9, -18, 18, 3);
        ctx.fillStyle = ep > 0.95 ? '#4CAF50' : ep > 0.25 ? '#FFA500' : '#FF4444';
        ctx.fillRect(-9, -18, 18 * ep, 3);
        
        ctx.restore();
      }
      
      draw() {
        if (!this.alive) return;
        // UPPDATERAD: Rita i boet
        if (this.inNest) {
          this.drawInNest();
          return;
        }
        
        ctx.save();
        ctx.translate(this.x, this.y);
        
        if (this.facing < 0) ctx.scale(-1, 1);
        
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath();
        ctx.ellipse(0, 14, 12, 4, 0, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = '#9C27B0';
        ctx.beginPath();
        ctx.ellipse(0, 0, 16, 10, 0, 0, Math.PI * 2);
        ctx.fill();
        
        const flap = Math.sin(globalTime * 0.3) * 0.5;
        ctx.save();
        ctx.rotate(flap);
        ctx.fillStyle = '#BA68C8';
        ctx.fillRect(-18, -3, 10, 3);
        ctx.restore();
        
        ctx.save();
        ctx.rotate(-flap);
        ctx.fillStyle = '#BA68C8';
        ctx.fillRect(8, -3, 10, 3);
        ctx.restore();
        
        ctx.fillStyle = '#7B1FA2';
        ctx.beginPath();
        ctx.arc(10, -3, 5, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = '#FF0000';
        ctx.beginPath();
        ctx.arc(12, -4, 2.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(12, -4, 1, 0, Math.PI * 2);
        ctx.fill();
        
        const ep = clamp(this.energy / this.maxEnergy);
        ctx.fillStyle = 'rgba(0,0,0,0.4)';
        ctx.fillRect(-9, -18, 18, 3);
        ctx.fillStyle = ep > 0.5 ? '#4CAF50' : ep > 0.25 ? '#FFA500' : '#FF4444';
        ctx.fillRect(-9, -18, 18 * ep, 3);
        
        if (this.kills > 0) {
          ctx.fillStyle = '#FFD700';
          ctx.font = 'bold 10px Arial';
          ctx.textAlign = 'center';
          ctx.fillText(`${this.kills}`, 0, -23);
        }
        
        ctx.restore();
      }
    }
    
    function buildPredatorNests(count) {
      predNests = [];
      if (count <= 0) return;

      const nestCenterX = canvas.width - 220;
      const nestOffsetX = 90;
      const nestStartY = 160;
      const nestSpacingY = 200;
      let nestsPlaced = 0;
      let row = 0;

      while (nestsPlaced < count) {
        const remaining = count - nestsPlaced;
        const y = nestStartY + row * nestSpacingY;
        if (remaining === 1) {
          predNests.push(new PredatorNest(nestCenterX, y));
          nestsPlaced += 1;
        } else {
          predNests.push(new PredatorNest(nestCenterX - nestOffsetX, y));
          if (nestsPlaced + 1 < count) {
            predNests.push(new PredatorNest(nestCenterX + nestOffsetX, y));
            nestsPlaced += 2;
          } else {
            nestsPlaced += 1;
          }
        }
        row++;
      }
    }

    // Init functions
    function initEnvironment() {
      hideSpots = [];
      const hidePositions = [
        {x: 250, y: 200}, {x: 400, y: 350}, {x: 200, y: 500},
        {x: 550, y: 250}, {x: 650, y: 450}, {x: 450, y: 600},
        {x: 350, y: 700}, {x: 800, y: 300}, {x: 900, y: 550},
        {x: 750, y: 700}, {x: 300, y: 400}, {x: 600, y: 650},
        {x: 500, y: 150}, {x: 700, y: 200}, {x: 850, y: 450}
      ];
      for (let i = 0; i < HIDE_SPOT_COUNT; i++) {
        const pos = hidePositions[i % hidePositions.length];
        hideSpots.push(new HideSpot(pos.x, pos.y));
      }
      buildPredatorNests(PRED_COUNT);
      
      // NEW: Init Trees
      trees = [];
      for (let i = 0; i < TREE_COUNT; i++) {
        const treeWidth = 25 + Math.random() * 20;
        const treeHeight = 150 + Math.random() * 300;
        // Undvik kanter och fiendebon
        const x = 200 + Math.random() * (canvas.width - 600); 
        trees.push(new Tree(x, treeWidth, treeHeight));
      }
      
      // NYTT: Init Bo & Kvistar
      birdNest = new BirdNest(NEST_X, NEST_Y); // Bottom left
      regenerateTwigPile();
      twigsInNest = 0;

      grassBlades = [];
      for (let x = 0; x < canvas.width; x += 6) {
        grassBlades.push({
          x,
          width: 3 + Math.random() * 2,
          height: 8 + Math.random() * 12
        });
      }

      seedInitialFood();
    }
    
    function initBirds() {
      birds = [];
      const allocations = getBirdTypeAllocations(BIRD_COUNT);

      BIRD_TYPE_KEYS.forEach(type => {
        const target = allocations[type];
        for (let i = 0; i < target; i++) {
          birds.push(new Bird(type));
        }
      });
    }

    function initPredators() {
      predators = [];
      for (let i = 0; i < PRED_COUNT; i++) {
        predators.push(new Predator());
      }
    }

    function spawnFood() {
      if (Math.random() < FOOD_SPAWN_RATE * 0.01) {
        const x = 100 + Math.random() * (canvas.width - 200);
        const y = 100 + Math.random() * (GROUND_Y - 200);
        foodParticles.push(new FoodParticle(x, y));
      }
    }

    function seedInitialFood(count = INITIAL_FOOD_COUNT) {
      for (let i = 0; i < count; i++) {
        const x = 120 + Math.random() * (canvas.width - 240);
        const y = 120 + Math.random() * (GROUND_Y - 240);
        foodParticles.push(new FoodParticle(x, y));
      }
    }
    
    function evolveBirds() {
      const newBirds = [];
      const allocations = getBirdTypeAllocations(BIRD_COUNT);

      for (const type of BIRD_TYPE_KEYS) {
        const typeBirds = birds.filter(b => b.type === type);
        typeBirds.sort((a, b) => b.fitness - a.fitness);

        const targetCount = allocations[type];
        if (targetCount === 0) {
          continue;
        }
        const eliteCount = Math.max(1, Math.floor(targetCount * BIRD_ELITE_RATE));

        for (let i = 0; i < eliteCount && i < typeBirds.length; i++) {
          newBirds.push(new Bird(type, typeBirds[i].brain.copy()));
        }

        const poolSize = Math.max(eliteCount, Math.floor(targetCount * BIRD_PARENT_POOL));
        let currentCount = newBirds.filter(b => b.type === type).length;
        while (currentCount < targetCount) {
          const parent = typeBirds[Math.floor(Math.random() * Math.min(typeBirds.length, poolSize))];
          if (parent) {
            const childBrain = parent.brain.copy();
            childBrain.mutate(BIRD_MUT_RATE, BIRD_MUT_POWER);
            newBirds.push(new Bird(type, childBrain));
          } else {
            newBirds.push(new Bird(type)); // Creates new brain
          }
          currentCount++;
        }
      }
      
      birds = newBirds;
      birds.forEach(b => b.reset());
    }
    
    function evolvePredators() {
      predators.sort((a, b) => b.fitness - a.fitness);
      const newPreds = [];
      
      if (PRED_COUNT === 0) {
        predators = [];
        buildPredatorNests(0);
        return;
      }

      const eliteCount = Math.max(1, Math.floor(PRED_COUNT * PRED_ELITE_RATE));
      for (let i = 0; i < eliteCount && i < predators.length; i++) {
        const newPred = new Predator(predators[i].brain.copy());
        if (PRED_EVOLVE) newPred.huntBonus = predators[i].huntBonus * 0.8;
        newPreds.push(newPred);
      }
      
      const poolSize = Math.max(eliteCount, Math.floor(PRED_COUNT * PRED_PARENT_POOL));
      while (newPreds.length < PRED_COUNT) {
        const parent = predators[Math.floor(Math.random() * Math.min(predators.length, poolSize))];
        if (parent) {
          const childBrain = parent.brain.copy();
          childBrain.mutate(PRED_MUT_RATE, PRED_MUT_POWER);
          const newPred = new Predator(childBrain);
          if (PRED_EVOLVE) newPred.huntBonus = parent.huntBonus * 0.6;
          newPreds.push(newPred);
        } else {
          newPreds.push(new Predator());
        }
      }
      
      predators = newPreds;
      predators.forEach(p => p.reset());
    }
    
    function nextGeneration() {
      generation++;
      evolveBirds();
      evolvePredators();
      survivalTime = 0;
      foodParticles = [];
      deadThisGen = 0;
      enemyWinAwarded = false;
      matingTimers.clear();

      // Reset the nest for the next generation
      birdNest = new BirdNest(NEST_X, NEST_Y);
      regenerateTwigPile();
      twigsInNest = 0;

      seedInitialFood();
    }
    
    function updateHUD() {
      document.getElementById('genValue').textContent = generation;
      document.getElementById('timeValue').textContent = Math.floor(survivalTime / 60) + 's';
      document.getElementById('birdsAlive').textContent = birds.filter(b => b.alive).length;
      document.getElementById('deadThisGen').textContent = deadThisGen;
      document.getElementById('predsCharging').textContent = predators.filter(p => p.alive && p.inNest).length;
      document.getElementById('enemyWins').textContent = enemyWinCount;
      
      const scouts = birds.filter(b => b.type === 'SCOUT' && b.alive).length;
      const thinkers = birds.filter(b => b.type === 'THINKER' && b.alive).length;
      const flockers = birds.filter(b => b.type === 'FLOCKER' && b.alive).length;
      const allocations = getBirdTypeAllocations(BIRD_COUNT);
      const perTypeScout = allocations.SCOUT || 1;
      const perTypeThinker = allocations.THINKER || 1;
      const perTypeFlocker = allocations.FLOCKER || 1;

      document.getElementById('scoutCount').textContent = scouts;
      document.getElementById('thinkerCount').textContent = thinkers;
      document.getElementById('flockerCount').textContent = flockers;

      document.getElementById('scoutBar').style.width = (scouts / perTypeScout * 100) + '%';
      document.getElementById('thinkerBar').style.width = (thinkers / perTypeThinker * 100) + '%';
      document.getElementById('flockerBar').style.width = (flockers / perTypeFlocker * 100) + '%';
      
      document.getElementById('totalEaten').textContent = totalEaten;
      document.getElementById('birdsHiding').textContent = birds.filter(b => b.hiding).length;
      document.getElementById('foodActive').textContent = foodParticles.filter(f => !f.eaten).length;

      // NEW: HUD for twigs
      document.getElementById('twigsInNest').textContent = twigsInNest;
      document.getElementById('twigBar').style.width = (twigsInNest / TWIG_PILE_COUNT * 100) + '%';

      document.getElementById('recordBestFitness').textContent = Math.round(recordBestFitness);
      document.getElementById('recordLongestLife').textContent = (recordLongestLife / 60).toFixed(1) + 's';
      document.getElementById('recordLargestNest').textContent = recordLargestNest;
      document.getElementById('recordMostKills').textContent = recordMostKills;

      document.getElementById('birdWallCrashes').textContent = telemetry.birdWallCrashes; // @added
      document.getElementById('predWallCrashes').textContent = telemetry.predWallCrashes; // @added
      document.getElementById('avgWallDist').textContent = telemetry.avgWallDist.toFixed(0); // @added
      document.getElementById('twigDeliveriesStat').textContent = telemetry.twigDeliveries; // @added
      document.getElementById('idleBreaksStat').textContent = telemetry.idleBreaks; // @added
      document.getElementById('birdStateEvade').textContent = (telemetry.birdStateTime.EVADE / 60).toFixed(1) + 's'; // @added
      document.getElementById('birdStateTwig').textContent = (telemetry.birdStateTime.COLLECT_TWIG / 60).toFixed(1) + 's'; // @added
      document.getElementById('birdStateForage').textContent = (telemetry.birdStateTime.FORAGE / 60).toFixed(1) + 's'; // @added
      document.getElementById('birdStateReturn').textContent = (telemetry.birdStateTime.RETURN_HOME / 60).toFixed(1) + 's'; // @added
      document.getElementById('predStateSearch').textContent = (telemetry.predStateTime.SEARCH / 60).toFixed(1) + 's'; // @added
      document.getElementById('predStateChase').textContent = (telemetry.predStateTime.CHASE / 60).toFixed(1) + 's'; // @added
      document.getElementById('predStateFlank').textContent = (telemetry.predStateTime.FLANK / 60).toFixed(1) + 's'; // @added
      document.getElementById('predStateAmbush').textContent = (telemetry.predStateTime.AMBUSH / 60).toFixed(1) + 's'; // @added
      document.getElementById('predStateRetreat').textContent = (telemetry.predStateTime.RETREAT / 60).toFixed(1) + 's'; // @added
      document.getElementById('predStateNest').textContent = (telemetry.predStateTime.NEST / 60).toFixed(1) + 's'; // @added
    }

    function handleBirdMating() {
      matingTimers.forEach((_, key) => {
        const [idA, idB] = key.split('-').map(Number);
        const birdA = birds.find(b => b.id === idA);
        const birdB = birds.find(b => b.id === idB);
        if (!birdA || !birdB || !birdA.alive || !birdB.alive || birdA.hiding || birdB.hiding) {
          matingTimers.delete(key);
        }
      });

      const newBirds = [];
      for (let i = 0; i < birds.length; i++) {
        const birdA = birds[i];
        if (!birdA.alive || birdA.hiding) continue;
        for (let j = i + 1; j < birds.length; j++) {
          const birdB = birds[j];
          if (!birdB.alive || birdB.hiding) continue;

          const key = birdA.id < birdB.id ? `${birdA.id}-${birdB.id}` : `${birdB.id}-${birdA.id}`;

          if (birdA.matingCooldown > 0 || birdB.matingCooldown > 0) {
            matingTimers.delete(key);
            continue;
          }

          const dist = Math.hypot(birdA.x - birdB.x, birdA.y - birdB.y);
          if (dist <= MATING_DISTANCE) {
            const timer = (matingTimers.get(key) || 0) + 1;
            if (timer >= MATING_REQUIRED_FRAMES) {
              matingTimers.delete(key);
              birdA.matingCooldown = MATING_COOLDOWN_FRAMES;
              birdB.matingCooldown = MATING_COOLDOWN_FRAMES;
              birdA.fitness += MATING_FITNESS_BONUS;
              birdB.fitness += MATING_FITNESS_BONUS;

              const chosenType = Math.random() < 0.5 ? birdA.type : birdB.type;
              const childBrain = birdA.brain.crossover(birdB.brain, 0.5);
              childBrain.mutate(BIRD_MUT_RATE * 0.5, BIRD_MUT_POWER * 0.5);
              const hatchling = new Bird(chosenType, childBrain);
              hatchling.x = (birdA.x + birdB.x) / 2;
              hatchling.y = (birdA.y + birdB.y) / 2;
              hatchling.vx = 0;
              hatchling.vy = 0;
              hatchling.lastIdlePos = { x: hatchling.x, y: hatchling.y };
              hatchling.matingCooldown = MATING_COOLDOWN_FRAMES;
              newBirds.push(hatchling);

              for (let k = 0; k < 18; k++) {
                particles.push(new Particle(hatchling.x, hatchling.y, '#FFD700'));
              }
            } else {
              matingTimers.set(key, timer);
            }
          } else {
            matingTimers.delete(key);
          }
        }
      }

      return newBirds;
    }

    function step() {
      globalTime++;
      survivalTime++;
      
      spawnFood();
      
      foodParticles = foodParticles.filter(f => !f.eaten);
      foodParticles.forEach(f => f.update());
      
      birds.forEach(b => {
        b.think();
        b.update();
      });

      const hatchlings = handleBirdMating();
      if (hatchlings.length > 0) {
        hatchlings.forEach(b => birds.push(b));
      }

      predators.forEach(p => p.update());
      
      particles = particles.filter(p => {
        p.update();
        return p.life > 0;
      });
      
      alarmWaves = alarmWaves.filter(w => {
        w.update();
        return w.life > 0;
      });
      
      hideSpots.forEach(h => {
        h.occupants = h.occupants.filter(b => b.hiding);
      });
      
      const smallBirdsAlive = birds.some(b => b.alive);
      const predatorsAlive = predators.some(p => p.alive);

      if (!smallBirdsAlive && predatorsAlive && !enemyWinAwarded && predators.length > 0 && globalTime > 100) {
        enemyWinCount++;
        enemyWinAwarded = true;
        predators.forEach(p => {
          p.fitness += ENEMY_WIN_FITNESS;
          if (p.alive) {
            p.energy = Math.min(p.maxEnergy, p.energy + ENEMY_WIN_ENERGY_BONUS);
          }
        });

        nextGeneration();
        return;
      }

      if (!smallBirdsAlive && !predatorsAlive && globalTime > 100) { // Small delay
        nextGeneration();
      }
    }
    
    function draw() {
      if (backgroundReady) {
        ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);
      } else {
        ctx.fillStyle = '#87CEEB';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.fillStyle = 'rgba(255,255,255,0.7)';
        for (let i = 0; i < 4; i++) {
          const x = 200 + i * 400;
          const y = 80 + Math.sin(globalTime * 0.01 + i) * 20;
          ctx.beginPath();
          ctx.arc(x, y, 40, 0, Math.PI * 2);
          ctx.arc(x + 30, y - 10, 50, 0, Math.PI * 2);
          ctx.arc(x + 60, y, 45, 0, Math.PI * 2);
          ctx.fill();
        }

        ctx.fillStyle = '#8B7355';
        ctx.fillRect(0, GROUND_Y, canvas.width, 50);
      }

      if (backgroundReady) {
        ctx.fillStyle = 'rgba(139, 115, 85, 0.35)';
        ctx.fillRect(0, GROUND_Y, canvas.width, 50);
      }

      ctx.fillStyle = backgroundReady ? 'rgba(107, 142, 35, 0.7)' : '#6B8E23';
      grassBlades.forEach(blade => {
        ctx.fillRect(blade.x, GROUND_Y - blade.height, blade.width, blade.height);
      });
      
      // UPPDATERAD Rit-ordning
      hideSpots.forEach(h => h.draw());
      predNests.forEach(n => n.draw());
      
      if (birdNest) birdNest.draw(); // NYTT
      trees.forEach(t => t.draw()); // NYTT
      
      // Draw twigs that are not carried
      twigPile.forEach(t => t.draw()); // NYTT
      
      alarmWaves.forEach(w => w.draw());
      foodParticles.forEach(f => f.draw());
      particles.forEach(p => p.draw());
      birds.forEach(b => b.draw());
      
      // Draw BOTH flying and charging predators
      predators.forEach(p => p.draw()); 
      
      updateHUD();
    }
    
    function gameLoop() {
      if (!paused) {
        for (let i = 0; i < timeScale; i++) {
          step();
        }
      }
      draw();
      requestAnimationFrame(gameLoop);
    }
    
    function resetSimulation() {
      generation = 1;
      globalTime = 0;
      survivalTime = 0;
      totalEaten = 0;
      deadThisGen = 0;
      paused = false;
      particles = [];
      foodParticles = [];
      alarmWaves = [];
      trees = []; // NYTT
      twigPile = []; // NYTT
      birdNest = null; // NYTT
      grassBlades = [];
      enemyWinCount = 0;
      enemyWinAwarded = false;
      matingTimers.clear();
      birdIdCounter = 0;

      telemetry.birdWallCrashes = 0; // @added
      telemetry.predWallCrashes = 0; // @added
      telemetry.twigDeliveries = 0; // @added
      telemetry.idleBreaks = 0; // @added
      telemetry.avgWallDist = 0; // @added
      Object.keys(telemetry.birdStateTime).forEach(k => telemetry.birdStateTime[k] = 0); // @added
      Object.keys(telemetry.predStateTime).forEach(k => telemetry.predStateTime[k] = 0); // @added

      initEnvironment();
      initBirds();
      initPredators();
    }
    
    resetSimulation();
    gameLoop();
  </script>
</body>
</html>
