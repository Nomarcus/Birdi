<!DOCTYPE html>
<html lang="sv">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Birdi ‚Äì Enkla flocken</title>
  <style>
    :root {
      color-scheme: dark;
      --bg-top: #101627;
      --bg-bottom: #070a11;
      --panel: rgba(18, 26, 44, 0.85);
      --panel-border: rgba(108, 126, 255, 0.3);
      --ink: #f3f6ff;
      --muted: #8d95bb;
      --accent: #7f8cff;
      --accent-strong: #4d5ce6;
      --danger: #ff6f91;
      --ok: #7ce0a7;
    }

    *, *::before, *::after {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      font-family: "Inter", system-ui, -apple-system, Segoe UI, sans-serif;
      color: var(--ink);
      background: radial-gradient(circle at 20% 20%, rgba(68, 96, 222, 0.25), transparent 55%),
        radial-gradient(circle at 80% 10%, rgba(255, 110, 158, 0.22), transparent 50%),
        linear-gradient(180deg, var(--bg-top), var(--bg-bottom));
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 24px;
      padding: 32px 20px 48px;
    }

    h1 {
      margin: 0;
      font-size: clamp(1.8rem, 3vw, 2.3rem);
      font-weight: 800;
      letter-spacing: 0.04em;
      text-align: center;
      text-shadow: 0 18px 40px rgba(103, 121, 255, 0.35);
    }

    .toolbar {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: center;
      gap: 16px;
      padding: 20px 24px;
      background: var(--panel);
      border: 1px solid var(--panel-border);
      border-radius: 22px;
      box-shadow: 0 26px 60px rgba(8, 10, 24, 0.55);
      backdrop-filter: blur(18px);
    }

    .btn {
      appearance: none;
      border: none;
      border-radius: 14px;
      font-weight: 700;
      font-size: 0.95rem;
      padding: 12px 22px;
      cursor: pointer;
      color: #05080f;
      background: linear-gradient(135deg, #7ce0a7, #51c98a);
      box-shadow: 0 16px 40px rgba(81, 201, 138, 0.35);
      transition: transform 0.2s ease, box-shadow 0.2s ease;
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }

    .btn.secondary {
      background: linear-gradient(135deg, #8d98ff, #5f6fff);
      box-shadow: 0 16px 40px rgba(127, 140, 255, 0.35);
      color: #f6f7ff;
    }

    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 20px 44px rgba(95, 210, 160, 0.38);
    }

    .btn.secondary:hover {
      box-shadow: 0 20px 44px rgba(127, 140, 255, 0.4);
    }

    .speed-control {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 18px;
      background: rgba(18, 24, 40, 0.9);
      border-radius: 16px;
      border: 1px solid rgba(125, 141, 255, 0.32);
    }

    .speed-control label {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: var(--muted);
      font-weight: 700;
    }

    input[type="range"] {
      accent-color: var(--accent);
      cursor: pointer;
    }

    .speed-value {
      min-width: 40px;
      text-align: right;
      font-weight: 700;
      color: var(--accent);
    }

    canvas {
      width: min(100%, 1100px);
      height: auto;
      border-radius: 22px;
      border: 4px solid rgba(101, 112, 214, 0.4);
      box-shadow: 0 40px 90px rgba(8, 12, 32, 0.65);
      background: linear-gradient(180deg, #9cd8ff, #6f9ee6 40%, #5a86d1 60%, #1d356b 100%);
    }

    .stats {
      width: min(1100px, 96vw);
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 14px;
    }

    .stat {
      padding: 16px 18px;
      background: var(--panel);
      border-radius: 18px;
      border: 1px solid var(--panel-border);
      display: flex;
      flex-direction: column;
      gap: 6px;
      box-shadow: 0 20px 48px rgba(7, 9, 24, 0.55);
      backdrop-filter: blur(18px);
    }

    .stat .label {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: var(--muted);
      font-weight: 700;
    }

    .stat .value {
      font-size: 1.8rem;
      font-weight: 800;
      letter-spacing: 0.04em;
    }

    footer {
      text-align: center;
      color: var(--muted);
      font-size: 0.85rem;
      max-width: 640px;
      line-height: 1.5;
    }
  </style>
</head>
<body>
  <h1>üê¶ Birdi ‚Äì En flock, en fiende</h1>

  <div class="toolbar">
    <button class="btn" id="btnReset">üîÑ Ny omg√•ng</button>
    <button class="btn secondary" id="btnPause">‚è∏Ô∏è Pausa</button>
    <div class="speed-control">
      <label for="speedSlider">Hastighet</label>
      <input type="range" id="speedSlider" min="0.25" max="4" step="0.25" value="1">
      <span class="speed-value" id="speedDisplay">1√ó</span>
    </div>
  </div>

  <canvas id="canvas" width="1100" height="680"></canvas>

  <div class="stats">
    <div class="stat">
      <span class="label">Generation</span>
      <span class="value" id="statGeneration">1</span>
    </div>
    <div class="stat">
      <span class="label">F√•glar kvar</span>
      <span class="value" id="statBirds">0</span>
    </div>
    <div class="stat">
      <span class="label">Fiender</span>
      <span class="value" id="statEnemies">0</span>
    </div>
    <div class="stat">
      <span class="label">√ñverlevnad</span>
      <span class="value" id="statTime">0.0 s</span>
    </div>
    <div class="stat">
      <span class="label">B√§sta tiden</span>
      <span class="value" id="statBest">0.0 s</span>
    </div>
  </div>

  <footer>
    En strippad version av Birdi ‚Äì bara en sorts f√•glar som h√•ller ihop och en sorts fiender som jagar. Se hur l√§nge flocken
    kan h√•lla sig vid liv innan n√§sta generation tar vid.
  </footer>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const dpr = window.devicePixelRatio || 1;
    const baseWidth = canvas.width;
    const baseHeight = canvas.height;

    canvas.width = baseWidth * dpr;
    canvas.height = baseHeight * dpr;
    ctx.scale(dpr, dpr);

    const config = {
      birdCount: 28,
      enemyCount: 3,
      birdSpeed: 150,
      enemySpeed: 180,
      separationRadius: 42,
      cohesionRadius: 160,
      alignmentRadius: 120,
      separationStrength: 280,
      cohesionStrength: 28,
      alignmentStrength: 42,
      enemySenseRadius: 220,
      enemyAvoidStrength: 340,
      wanderStrength: 22,
      boundaryStrength: 260,
      enemyTurnSpeed: 320,
      captureRadius: 16,
      padding: 60
    };

    const state = {
      birds: [],
      enemies: [],
      generation: 1,
      survivalTime: 0,
      bestTime: 0,
      paused: false,
      speed: 1,
      resetting: false
    };

    const elements = {
      birds: document.getElementById('statBirds'),
      enemies: document.getElementById('statEnemies'),
      generation: document.getElementById('statGeneration'),
      time: document.getElementById('statTime'),
      best: document.getElementById('statBest'),
      pause: document.getElementById('btnPause'),
      speedSlider: document.getElementById('speedSlider'),
      speedDisplay: document.getElementById('speedDisplay')
    };

    class Bird {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        const angle = Math.random() * Math.PI * 2;
        const speed = config.birdSpeed * 0.4;
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
        this.alive = true;
        this.wanderTimer = Math.random() * Math.PI * 2;
      }

      update(delta, birds, enemies) {
        if (!this.alive) return;

        let ax = 0;
        let ay = 0;

        // Separation & cohesion
        let separationCount = 0;
        let cohesionCount = 0;
        let alignmentCount = 0;
        let cohesionX = 0;
        let cohesionY = 0;
        let alignmentX = 0;
        let alignmentY = 0;

        for (const other of birds) {
          if (other === this || !other.alive) continue;
          const dx = other.x - this.x;
          const dy = other.y - this.y;
          const dist = Math.hypot(dx, dy);
          if (dist < 1) continue;

          if (dist < config.separationRadius) {
            const weight = 1 - dist / config.separationRadius;
            ax -= (dx / dist) * config.separationStrength * weight;
            ay -= (dy / dist) * config.separationStrength * weight;
            separationCount++;
          }

          if (dist < config.cohesionRadius) {
            cohesionX += other.x;
            cohesionY += other.y;
            cohesionCount++;
          }

          if (dist < config.alignmentRadius) {
            alignmentX += other.vx;
            alignmentY += other.vy;
            alignmentCount++;
          }
        }

        if (cohesionCount > 0) {
          const cx = cohesionX / cohesionCount;
          const cy = cohesionY / cohesionCount;
          const dx = cx - this.x;
          const dy = cy - this.y;
          const dist = Math.hypot(dx, dy);
          if (dist > 1) {
            ax += (dx / dist) * config.cohesionStrength;
            ay += (dy / dist) * config.cohesionStrength;
          }
        }

        if (alignmentCount > 0) {
          const avx = alignmentX / alignmentCount;
          const avy = alignmentY / alignmentCount;
          const dist = Math.hypot(avx, avy);
          if (dist > 1) {
            ax += (avx / dist) * config.alignmentStrength;
            ay += (avy / dist) * config.alignmentStrength;
          }
        }

        // Avoid enemies
        let nearestEnemy = null;
        let nearestDist = Infinity;
        for (const enemy of enemies) {
          const dx = enemy.x - this.x;
          const dy = enemy.y - this.y;
          const dist = Math.hypot(dx, dy);
          if (dist < nearestDist) {
            nearestDist = dist;
            nearestEnemy = enemy;
          }
        }

        if (nearestEnemy && nearestDist < config.enemySenseRadius) {
          const dx = this.x - nearestEnemy.x;
          const dy = this.y - nearestEnemy.y;
          const dist = Math.max(1, nearestDist);
          const weight = 1 - Math.min(1, dist / config.enemySenseRadius);
          ax += (dx / dist) * config.enemyAvoidStrength * weight;
          ay += (dy / dist) * config.enemyAvoidStrength * weight;
        }

        // Keep inside the world
        const { padding } = config;
        if (this.x < padding) ax += config.boundaryStrength;
        else if (this.x > baseWidth - padding) ax -= config.boundaryStrength;
        if (this.y < padding) ay += config.boundaryStrength;
        else if (this.y > baseHeight - padding) ay -= config.boundaryStrength;

        // Gentle wander to avoid stagnation
        this.wanderTimer += delta * 2;
        ax += Math.cos(this.wanderTimer) * config.wanderStrength;
        ay += Math.sin(this.wanderTimer) * config.wanderStrength;

        this.vx += ax * delta;
        this.vy += ay * delta;

        const speed = Math.hypot(this.vx, this.vy);
        const maxSpeed = config.birdSpeed;
        if (speed > maxSpeed) {
          const scale = maxSpeed / speed;
          this.vx *= scale;
          this.vy *= scale;
        }

        this.x += this.vx * delta;
        this.y += this.vy * delta;
        this.x = Math.max(padding, Math.min(baseWidth - padding, this.x));
        this.y = Math.max(padding, Math.min(baseHeight - padding, this.y));
      }

      draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        const angle = Math.atan2(this.vy, this.vx);
        ctx.rotate(angle);
        ctx.fillStyle = '#ffe27a';
        ctx.strokeStyle = '#c9973e';
        ctx.lineWidth = 2;

        ctx.beginPath();
        ctx.moveTo(14, 0);
        ctx.quadraticCurveTo(-4, 8, -12, 0);
        ctx.quadraticCurveTo(-4, -8, 14, 0);
        ctx.fill();
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(-4, -2);
        ctx.lineTo(-12, -16);
        ctx.moveTo(-4, 2);
        ctx.lineTo(-12, 16);
        ctx.stroke();

        ctx.restore();
      }
    }

    class Enemy {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        const angle = Math.random() * Math.PI * 2;
        this.vx = Math.cos(angle) * config.enemySpeed * 0.3;
        this.vy = Math.sin(angle) * config.enemySpeed * 0.3;
        this.target = null;
      }

      update(delta, birds) {
        // acquire target
        if (!this.target || !this.target.alive) {
          let closest = null;
          let bestDist = Infinity;
          for (const bird of birds) {
            if (!bird.alive) continue;
            const dx = bird.x - this.x;
            const dy = bird.y - this.y;
            const dist = Math.hypot(dx, dy);
            if (dist < bestDist) {
              bestDist = dist;
              closest = bird;
            }
          }
          this.target = closest;
        }

        let ax = 0;
        let ay = 0;

        if (this.target) {
          const dx = this.target.x - this.x;
          const dy = this.target.y - this.y;
          const dist = Math.hypot(dx, dy);
          if (dist > 1) {
            ax += (dx / dist) * config.enemyTurnSpeed;
            ay += (dy / dist) * config.enemyTurnSpeed;
          }

          if (dist < config.captureRadius && this.target.alive) {
            this.target.alive = false;
            this.target = null;
          }
        } else {
          ax += (Math.random() - 0.5) * config.enemyTurnSpeed * 0.2;
          ay += (Math.random() - 0.5) * config.enemyTurnSpeed * 0.2;
        }

        const { padding } = config;
        if (this.x < padding) ax += config.boundaryStrength * 0.6;
        else if (this.x > baseWidth - padding) ax -= config.boundaryStrength * 0.6;
        if (this.y < padding) ay += config.boundaryStrength * 0.6;
        else if (this.y > baseHeight - padding) ay -= config.boundaryStrength * 0.6;

        this.vx += ax * delta;
        this.vy += ay * delta;

        const speed = Math.hypot(this.vx, this.vy);
        const maxSpeed = config.enemySpeed;
        if (speed > maxSpeed) {
          const scale = maxSpeed / speed;
          this.vx *= scale;
          this.vy *= scale;
        }

        this.x += this.vx * delta;
        this.y += this.vy * delta;
        this.x = Math.max(padding, Math.min(baseWidth - padding, this.x));
        this.y = Math.max(padding, Math.min(baseHeight - padding, this.y));
      }

      draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        const angle = Math.atan2(this.vy, this.vx);
        ctx.rotate(angle);
        ctx.fillStyle = '#ff6f91';
        ctx.strokeStyle = '#d64f6f';
        ctx.lineWidth = 2;

        ctx.beginPath();
        ctx.moveTo(18, 0);
        ctx.lineTo(-14, 10);
        ctx.lineTo(-6, 0);
        ctx.lineTo(-14, -10);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        ctx.restore();
      }
    }

    function spawnBird() {
      const padding = config.padding;
      const x = padding + Math.random() * (baseWidth - padding * 2);
      const y = padding + Math.random() * (baseHeight - padding * 2);
      return new Bird(x, y);
    }

    function spawnEnemy() {
      const padding = config.padding;
      const x = padding + Math.random() * (baseWidth - padding * 2);
      const y = padding + Math.random() * (baseHeight - padding * 2);
      return new Enemy(x, y);
    }

    function resetSimulation() {
      state.birds = Array.from({ length: config.birdCount }, spawnBird);
      state.enemies = Array.from({ length: config.enemyCount }, spawnEnemy);
      state.survivalTime = 0;
      state.resetting = false;
      state.paused = false;
      elements.pause.textContent = '‚è∏Ô∏è Pausa';
      updateStats();
    }

    function updateStats() {
      const aliveBirds = state.birds.filter(b => b.alive).length;
      elements.birds.textContent = aliveBirds;
      elements.enemies.textContent = state.enemies.length;
      elements.generation.textContent = state.generation;
      elements.time.textContent = `${state.survivalTime.toFixed(1)} s`;
      elements.best.textContent = `${state.bestTime.toFixed(1)} s`;
    }

    let lastTime = performance.now();

    function loop(now) {
      requestAnimationFrame(loop);
      const rawDelta = Math.min(0.05, (now - lastTime) / 1000);
      lastTime = now;
      if (state.paused) {
        drawScene();
        return;
      }

      const delta = rawDelta * state.speed;
      const hadLivingBird = state.birds.some(bird => bird.alive);
      for (const bird of state.birds) {
        bird.update(delta, state.birds, state.enemies);
      }

      for (const enemy of state.enemies) {
        enemy.update(delta, state.birds);
      }

      if (hadLivingBird) {
        state.survivalTime += delta;
      }

      const aliveBirds = state.birds.some(bird => bird.alive);
      if (!aliveBirds && !state.resetting) {
        state.resetting = true;
        state.bestTime = Math.max(state.bestTime, state.survivalTime);
        updateStats();
        setTimeout(() => {
          state.generation += 1;
          resetSimulation();
        }, 800);
      }

      updateStats();
      drawScene();
    }

    function drawScene() {
      ctx.clearRect(0, 0, baseWidth, baseHeight);

      // Ground
      const gradient = ctx.createLinearGradient(0, baseHeight * 0.55, 0, baseHeight);
      gradient.addColorStop(0, '#3d6bc2');
      gradient.addColorStop(1, '#183264');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, baseHeight * 0.55, baseWidth, baseHeight * 0.45);

      // subtle horizon line
      ctx.strokeStyle = 'rgba(255,255,255,0.15)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, baseHeight * 0.55);
      ctx.lineTo(baseWidth, baseHeight * 0.55);
      ctx.stroke();

      // soft sun
      const sunGradient = ctx.createRadialGradient(baseWidth * 0.75, baseHeight * 0.28, 0, baseWidth * 0.75, baseHeight * 0.28, 110);
      sunGradient.addColorStop(0, 'rgba(255,255,255,0.7)');
      sunGradient.addColorStop(1, 'rgba(255,255,255,0)');
      ctx.fillStyle = sunGradient;
      ctx.beginPath();
      ctx.arc(baseWidth * 0.75, baseHeight * 0.28, 110, 0, Math.PI * 2);
      ctx.fill();

      // draw birds & enemies
      for (const bird of state.birds) {
        if (bird.alive) {
          bird.draw(ctx);
        } else {
          ctx.save();
          ctx.globalAlpha = 0.25;
          ctx.fillStyle = '#d9e0ff';
          ctx.beginPath();
          ctx.arc(bird.x, bird.y, 6, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }
      }

      for (const enemy of state.enemies) {
        enemy.draw(ctx);
      }
    }

    document.getElementById('btnReset').addEventListener('click', () => {
      state.generation = 1;
      state.bestTime = 0;
      resetSimulation();
    });

    elements.pause.addEventListener('click', () => {
      state.paused = !state.paused;
      elements.pause.textContent = state.paused ? '‚ñ∂Ô∏è Forts√§tt' : '‚è∏Ô∏è Pausa';
    });

    elements.speedSlider.addEventListener('input', event => {
      const value = Number(event.target.value);
      state.speed = value;
      const text = value
        .toFixed(2)
        .replace(/\.00$/, '')
        .replace(/(\.\d)0$/, '$1');
      elements.speedDisplay.textContent = `${text}√ó`;
    });

    window.addEventListener('resize', () => {
      const rect = canvas.getBoundingClientRect();
      canvas.style.height = `${rect.width * (baseHeight / baseWidth)}px`;
    });

    elements.speedSlider.dispatchEvent(new Event('input'));
    resetSimulation();
    updateStats();
    requestAnimationFrame(loop);
  </script>
</body>
</html>
